<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Interactive Voronoi Grid</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #voronoiCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            pointer-events: none;
            opacity: 0;
            transform: translateY(5px);
            transition: opacity 0.2s, transform 0.2s;
            z-index: 100;
            white-space: nowrap;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* FPS Counter Overlay */
        .fps-overlay {
            position: absolute;
            bottom: 16px;
            left: 16px;
            z-index: 2147483647;
            user-select: none;
            font-family: ui-monospace, 'SF Mono', 'Monaco', 'Consolas', monospace;
        }

        .fps-container {
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            overflow: hidden;
            min-width: 200px;
        }

        .fps-container.minimized {
            min-width: auto;
        }

        .fps-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 12px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .fps-header:hover {
            background: rgba(255,255,255,0.1);
        }

        .fps-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .fps-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .fps-title {
            font-size: 12px;
            font-weight: 600;
        }

        .fps-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .fps-current {
            font-size: 14px;
            font-weight: 700;
        }

        .fps-toggle {
            font-size: 10px;
            color: rgba(255,255,255,0.4);
        }

        .fps-body {
            padding: 4px 12px 12px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .fps-stats-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: rgba(255,255,255,0.4);
            margin-bottom: 8px;
        }

        .fps-stat-value {
            color: white;
        }

        .fps-stat-value.good { color: #22c55e; }
        .fps-stat-value.bad { color: #ef4444; }

        .fps-frame-info {
            font-size: 10px;
            color: rgba(255,255,255,0.4);
            margin-bottom: 8px;
        }

        .fps-frame-value {
            color: white;
        }

        .fps-frame-target {
            color: rgba(255,255,255,0.3);
            margin-left: 8px;
        }

        .fps-graph-container {
            position: relative;
            background: rgba(0,0,0,0.5);
            border-radius: 4px;
            overflow: hidden;
        }

        .fps-graph-svg {
            display: block;
        }

        .fps-graph-label {
            position: absolute;
            right: 4px;
            font-size: 8px;
            color: rgba(255,255,255,0.3);
        }

        .fps-graph-label.top { top: 0; }
        .fps-graph-label.bottom { bottom: 0; }

        .fps-good { color: #22c55e; }
        .fps-ok { color: #eab308; }
        .fps-bad { color: #ef4444; }

        .controls {
            background: rgba(20, 20, 35, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255,255,255,0.1);
            padding: 12px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px 16px;
            align-items: flex-end;
        }

        .control-section {
            display: contents;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 100px;
        }

        .control-group.wide {
            min-width: 130px;
        }

        .control-group label {
            font-size: 9px;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        input[type="range"] {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.15);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(99,102,241,0.4);
            transition: transform 0.15s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .control-value {
            font-size: 11px;
            color: #fff;
            font-weight: 600;
            min-width: 28px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        .btn {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: #fff;
            box-shadow: 0 4px 15px rgba(99,102,241,0.3);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(99,102,241,0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.15);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.15);
        }

        .btn-secondary.active {
            background: rgba(99,102,241,0.3);
            border-color: rgba(99,102,241,0.5);
        }

        .divider {
            width: 1px;
            height: 36px;
            background: rgba(255,255,255,0.1);
        }

        /* Preset buttons (radio-style) */
        .preset-group {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .preset-label {
            font-size: 11px;
            color: rgba(255,255,255,0.6);
            margin-right: 4px;
        }

        .preset-btn {
            padding: 6px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(255,255,255,0.05);
            color: rgba(255,255,255,0.7);
        }

        .preset-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.3);
        }

        .preset-btn.active {
            background: linear-gradient(135deg, rgba(99,102,241,0.4), rgba(139,92,246,0.4));
            border-color: rgba(139,92,246,0.6);
            color: #fff;
            box-shadow: 0 2px 10px rgba(99,102,241,0.3);
        }

        @media (max-width: 1100px) {
            .control-group.hide-tablet {
                display: none;
            }
        }

        @media (max-width: 800px) {
            .controls {
                padding: 10px 12px;
                gap: 10px 12px;
            }
            .control-group.hide-mobile {
                display: none;
            }
            .btn-group {
                width: 100%;
                margin-left: 0;
                justify-content: flex-end;
            }
            .divider {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="canvas-container">
            <canvas id="voronoiCanvas"></canvas>
            <div class="tooltip" id="tooltip"></div>
            <div class="fps-overlay" id="fpsOverlay">
                <div class="fps-container" id="fpsContainer">
                    <div class="fps-header" id="fpsHeader">
                        <div class="fps-header-left">
                            <div class="fps-indicator" id="fpsIndicator"></div>
                            <span class="fps-title">FPS</span>
                        </div>
                        <div class="fps-header-right">
                            <span class="fps-current" id="fpsValue">60</span>
                            <span class="fps-toggle" id="fpsToggle">▼</span>
                        </div>
                    </div>
                    <div class="fps-body" id="fpsBody">
                        <div class="fps-stats-row">
                            <span>Avg: <span class="fps-stat-value" id="fpsAvg">60</span></span>
                            <span>Min: <span class="fps-stat-value bad" id="fpsMin">-</span></span>
                            <span>Max: <span class="fps-stat-value good" id="fpsMax">-</span></span>
                        </div>
                        <div class="fps-frame-info">
                            Frame: <span class="fps-frame-value" id="frameTimeValue">0.0ms</span>
                            <span class="fps-frame-target" id="fpsTarget">(16.7ms target)</span>
                        </div>
                        <div class="fps-graph-container">
                            <svg id="fpsGraph" class="fps-graph-svg" width="180" height="40">
                                <line x1="0" y1="20" x2="180" y2="20" stroke="#333" stroke-dasharray="2,2" />
                                <line id="fps60Line" x1="0" y1="20" x2="180" y2="20" stroke="#22c55e" stroke-dasharray="4,2" opacity="0.5" />
                                <path id="fpsAreaPath" fill="url(#fpsGradient)" opacity="0.3" />
                                <path id="fpsLinePath" fill="none" stroke="#22c55e" stroke-width="1.5" stroke-linejoin="round" />
                                <defs>
                                    <linearGradient id="fpsGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop id="fpsGradientStop" offset="0%" stop-color="#22c55e" />
                                        <stop offset="100%" stop-color="transparent" />
                                    </linearGradient>
                                </defs>
                            </svg>
                            <div class="fps-graph-label top">120</div>
                            <div class="fps-graph-label bottom">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="controls">
            <!-- Grid Settings -->
            <div class="control-group">
                <label>Cells</label>
                <div class="control-row">
                    <input type="range" id="cellCount" min="4" max="30" value="12">
                    <span class="control-value" id="cellCountVal">12</span>
                </div>
            </div>
            <div class="control-group">
                <label>Gap</label>
                <div class="control-row">
                    <input type="range" id="gap" min="0" max="30" value="27">
                    <span class="control-value" id="gapVal">27</span>
                </div>
            </div>
            <div class="control-group">
                <label>Corners</label>
                <div class="control-row">
                    <input type="range" id="cornerRadius" min="0" max="40" value="23">
                    <span class="control-value" id="cornerRadiusVal">23</span>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Hover Effect -->
            <div class="control-group">
                <label>Hover Size</label>
                <div class="control-row">
                    <input type="range" id="maxExpansion" min="0" max="400" value="400">
                    <span class="control-value" id="maxExpansionVal">400</span>
                </div>
            </div>
            <div class="control-group">
                <label>In Speed</label>
                <div class="control-row">
                    <input type="range" id="expansionSpeed" min="0" max="100" value="8">
                    <span class="control-value" id="expansionSpeedVal">8</span>
                </div>
            </div>
            <div class="control-group">
                <label>Out Speed</label>
                <div class="control-row">
                    <input type="range" id="retractionSpeed" min="0" max="100" value="2">
                    <span class="control-value" id="retractionSpeedVal">2</span>
                </div>
            </div>
            <div class="control-group">
                <label>Displace</label>
                <div class="control-row">
                    <input type="range" id="displaceRatio" min="0" max="100" value="100">
                    <span class="control-value" id="displaceRatioVal">1.00</span>
                </div>
            </div>
            <div class="control-group">
                <label>Falloff</label>
                <div class="control-row">
                    <input type="range" id="displaceFalloff" min="100" max="800" value="300">
                    <span class="control-value" id="displaceFalloffVal">300</span>
                </div>
            </div>
            <div class="control-group">
                <label>Dim Others</label>
                <div class="control-row">
                    <input type="range" id="nonHoveredOpacity" min="0" max="100" value="36">
                    <span class="control-value" id="nonHoveredOpacityVal">0.36</span>
                </div>
            </div>
            <div class="control-group hide-mobile">
                <label>Image Zoom</label>
                <div class="control-row">
                    <input type="range" id="nonHoverImageZoom" min="10" max="80" value="30" step="1">
                    <span class="control-value" id="nonHoverImageZoomVal">3.0</span>
                </div>
            </div>
            <div class="control-group hide-mobile">
                <label>Zoom Speed</label>
                <div class="control-row">
                    <input type="range" id="imageZoomSpeed" min="1" max="100" value="3">
                    <span class="control-value" id="imageZoomSpeedVal">3</span>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Bar Presets -->
            <div class="preset-group">
                <span class="preset-label">Layout:</span>
                <button class="preset-btn active" data-preset="horizontal">Horizontal</button>
                <button class="preset-btn" data-preset="vertical">Vertical</button>
                <button class="preset-btn" data-preset="diagonal">Diagonal</button>
            </div>

            <div class="divider"></div>

            <!-- Content Zone -->
            <div class="control-group">
                <label>Zone Margin</label>
                <div class="control-row">
                    <input type="range" id="contentZoneMargin" min="0" max="40" value="15">
                    <span class="control-value" id="contentZoneMarginVal">15%</span>
                </div>
            </div>
            <div class="control-group">
                <label>Zone Angle</label>
                <div class="control-row">
                    <input type="range" id="contentZoneRotation" min="0" max="315" value="0" step="45">
                    <span class="control-value" id="contentZoneRotationVal">0°</span>
                </div>
            </div>
            <div class="control-group">
                <label>Position</label>
                <div class="control-row">
                    <input type="range" id="contentZonePosition" min="-100" max="100" value="0">
                    <span class="control-value" id="contentZonePositionVal">0%</span>
                </div>
            </div>
            <div class="control-group hide-tablet">
                <label>Bleed Buffer</label>
                <div class="control-row">
                    <input type="range" id="bleedBuffer" min="20" max="200" value="158">
                    <span class="control-value" id="bleedBufferVal">158</span>
                </div>
            </div>
            <div class="control-group hide-tablet">
                <label>Trans Speed</label>
                <div class="control-row">
                    <input type="range" id="transitionSpeed" min="1" max="20" value="6">
                    <span class="control-value" id="transitionSpeedVal">6</span>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Buttons -->
            <div class="btn-group">
                <button class="btn btn-secondary" id="toggleContentZone">Zone</button>
                <button class="btn btn-secondary" id="toggleDebug">Debug</button>
                <button class="btn btn-secondary" id="loadUnsplash">Unsplash</button>
                <button class="btn btn-primary" id="regenerate">Regenerate</button>
            </div>
        </div>
    </div>

    <script>
    (function() {
        'use strict';

        // ========== CONFIGURATION ==========
        const config = {
            // Grid settings
            cellCount: 12,
            gap: 27,
            cornerRadius: 23,

            // Inflation system
            maxExpansion: 400,           // How much the hovered cell inflates (affects neighbor push)
            expansionSpeed: 8,           // How fast cells inflate (1-100 scale, higher = faster)
            retractionSpeed: 2,          // How fast cells retract after hover ends (1-100 scale)
            displaceRatio: 1.0,          // 0 = no neighbor push, 1 = max neighbor push
            displaceFalloff: 300,        // How far displacement reaches (px) - lower = more local, higher = affects distant cells

            // Visual transitions
            nonHoverImageZoom: 3.0,      // Non-hover image zoom level
            imageZoomSpeed: 3,           // How fast image zoom transitions (1-100 scale)
            nonHoveredOpacity: 0.36,     // Opacity for non-hovered cells
            opacityTransitionSpeed: 0.15, // How fast opacity transitions

            // Toggles
            physicsEnabled: true,
            debugMode: false,

            // Content zone / soft boundary
            contentZoneEnabled: true,    // Enable/disable content zone
            contentZoneMargin: 0.15,     // Margin as fraction of zone dimension
            contentZoneRotation: 0,      // Rotation in degrees (0 = horizontal, 90 = vertical)
            contentZonePosition: 0,      // Position offset (-1 to 1, perpendicular to bar orientation)
            bleedBuffer: 158,            // Pixel buffer beyond content zone (how far hovered cell can extend)

            // Bar layout presets
            currentPreset: 'horizontal', // 'horizontal', 'vertical', 'diagonal'
            transitionSpeed: 6,          // Speed of bar transitions (1-20)
            isTransitioning: false       // Whether cells are currently transitioning
        };

        // Preset definitions
        const presets = {
            horizontal: { rotation: 0, position: 0, margin: 0.15 },
            vertical: { rotation: 90, position: -0.7, margin: 0.15 },  // Left side
            diagonal: { rotation: 45, position: 0, margin: 0.15 }     // Bottom-left to top-right
        };

        // ========== SAMPLE DATA ==========
        const cellData = [
            { title: 'Cosmic Dreams', link: '#cosmic', color: '#6366f1' },
            { title: 'Ocean Depths', link: '#ocean', color: '#06b6d4' },
            { title: 'Forest Whispers', link: '#forest', color: '#10b981' },
            { title: 'Solar Flare', link: '#solar', color: '#f59e0b' },
            { title: 'Cherry Blossom', link: '#cherry', color: '#ec4899' },
            { title: 'Arctic Aurora', link: '#arctic', color: '#8b5cf6' },
            { title: 'Desert Gold', link: '#desert', color: '#eab308' },
            { title: 'Midnight Jazz', link: '#jazz', color: '#3b82f6' },
            { title: 'Ember Glow', link: '#ember', color: '#ef4444' },
            { title: 'Mint Fresh', link: '#mint', color: '#14b8a6' },
            { title: 'Lavender Fields', link: '#lavender', color: '#a855f7' },
            { title: 'Coral Reef', link: '#coral', color: '#f97316' },
            { title: 'Storm Cloud', link: '#storm', color: '#64748b' },
            { title: 'Neon Nights', link: '#neon', color: '#d946ef' },
            { title: 'Sage Garden', link: '#sage', color: '#84cc16' },
            { title: 'Ruby Dreams', link: '#ruby', color: '#dc2626' },
            { title: 'Sapphire Sky', link: '#sapphire', color: '#2563eb' },
            { title: 'Amber Waves', link: '#amber', color: '#d97706' },
            { title: 'Violet Hour', link: '#violet', color: '#7c3aed' },
            { title: 'Teal Depths', link: '#teal', color: '#0d9488' },
            { title: 'Rose Petals', link: '#rose', color: '#e11d48' },
            { title: 'Lime Zest', link: '#lime', color: '#65a30d' },
            { title: 'Indigo Night', link: '#indigo', color: '#4f46e5' },
            { title: 'Peach Sunset', link: '#peach', color: '#fb923c' },
            { title: 'Cyan Wave', link: '#cyan', color: '#22d3d8' },
            { title: 'Magenta Pulse', link: '#magenta', color: '#c026d3' },
            { title: 'Bronze Age', link: '#bronze', color: '#a16207' },
            { title: 'Steel Blue', link: '#steel', color: '#475569' },
            { title: 'Crimson Tide', link: '#crimson', color: '#be123c' },
            { title: 'Emerald City', link: '#emerald', color: '#059669' }
        ];

        // ========== STATE ==========
        let canvas, ctx;
        let width, height;
        let cells = [];
        let hoveredCell = -1;
        let mouseX = -9999, mouseY = -9999;
        let tooltip;
        let animationId;
        let lastTime = 0;

        // ========== FPS TRACKING ==========
        const FPS_HISTORY_SIZE = 60;
        const FPS_UPDATE_INTERVAL = 100; // Update display every N milliseconds
        const MAX_GRAPH_FPS = 120;
        const GRAPH_WIDTH = 180;
        const GRAPH_HEIGHT = 40;

        let fpsElements = null;
        let fpsHistory = [];
        let allFpsValues = [];
        let fpsFrameHistory = [];
        let lastFpsUpdateTime = 0;
        let isMinimized = false;

        function getFpsColor(fps) {
            return fps >= 55 ? '#22c55e' : fps >= 30 ? '#eab308' : '#ef4444';
        }

        function getFpsClass(fps) {
            return fps >= 55 ? 'fps-good' : fps >= 30 ? 'fps-ok' : 'fps-bad';
        }

        function generatePath(history) {
            if (history.length < 2) return '';
            return 'M ' + history.map((v, i) => {
                const x = (i / (FPS_HISTORY_SIZE - 1)) * GRAPH_WIDTH;
                const y = GRAPH_HEIGHT - (Math.min(v, MAX_GRAPH_FPS) / MAX_GRAPH_FPS) * GRAPH_HEIGHT;
                return `${x},${y}`;
            }).join(' L ');
        }

        function generateAreaPath(history) {
            if (history.length < 2) return '';
            const linePath = history.map((v, i) => {
                const x = (i / (FPS_HISTORY_SIZE - 1)) * GRAPH_WIDTH;
                const y = GRAPH_HEIGHT - (Math.min(v, MAX_GRAPH_FPS) / MAX_GRAPH_FPS) * GRAPH_HEIGHT;
                return `${x},${y}`;
            }).join(' L ');
            return `M 0,${GRAPH_HEIGHT} L ${linePath} L ${GRAPH_WIDTH},${GRAPH_HEIGHT} Z`;
        }

        function initFpsCounter() {
            fpsElements = {
                container: document.getElementById('fpsContainer'),
                header: document.getElementById('fpsHeader'),
                body: document.getElementById('fpsBody'),
                toggle: document.getElementById('fpsToggle'),
                indicator: document.getElementById('fpsIndicator'),
                value: document.getElementById('fpsValue'),
                avg: document.getElementById('fpsAvg'),
                min: document.getElementById('fpsMin'),
                max: document.getElementById('fpsMax'),
                frameTime: document.getElementById('frameTimeValue'),
                target: document.getElementById('fpsTarget'),
                linePath: document.getElementById('fpsLinePath'),
                areaPath: document.getElementById('fpsAreaPath'),
                gradientStop: document.getElementById('fpsGradientStop'),
                fps60Line: document.getElementById('fps60Line')
            };

            // Set 60 FPS line position
            const y60 = GRAPH_HEIGHT - (60 / MAX_GRAPH_FPS) * GRAPH_HEIGHT;
            fpsElements.fps60Line.setAttribute('y1', y60);
            fpsElements.fps60Line.setAttribute('y2', y60);

            // Toggle minimize/expand on header click
            fpsElements.header.addEventListener('click', () => {
                isMinimized = !isMinimized;
                fpsElements.body.style.display = isMinimized ? 'none' : 'block';
                fpsElements.toggle.textContent = isMinimized ? '▶' : '▼';
                fpsElements.container.classList.toggle('minimized', isMinimized);
            });

            // Initialize history
            for (let i = 0; i < FPS_HISTORY_SIZE; i++) {
                fpsHistory.push(60);
            }
        }

        function updateFpsCounter(deltaMs) {
            const instantFps = 1000 / deltaMs;

            // Track frame-by-frame FPS for averaging
            fpsFrameHistory.push(instantFps);
            if (fpsFrameHistory.length > 60) fpsFrameHistory.shift();

            const currentTime = performance.now();
            if (currentTime - lastFpsUpdateTime < FPS_UPDATE_INTERVAL) return;
            lastFpsUpdateTime = currentTime;

            // Calculate current FPS from recent frames
            const recentFps = fpsFrameHistory.slice(-10);
            const currentFps = recentFps.length > 0
                ? recentFps.reduce((a, b) => a + b, 0) / recentFps.length : 0;
            const avgFps = fpsFrameHistory.length > 0
                ? fpsFrameHistory.reduce((a, b) => a + b, 0) / fpsFrameHistory.length : 0;

            // Track all FPS values for min/max
            allFpsValues.push(currentFps);
            if (allFpsValues.length > 600) allFpsValues.shift();
            const validValues = allFpsValues.filter(v => v > 0 && v < 1000);

            const fps = Math.round(currentFps);
            const avg = Math.round(avgFps);
            const min = validValues.length > 0 ? Math.round(Math.min(...validValues)) : 0;
            const max = validValues.length > 0 ? Math.round(Math.max(...validValues)) : 0;

            // Update history for graph
            fpsHistory.shift();
            fpsHistory.push(fps);

            // Update display
            const color = getFpsColor(fps);
            fpsElements.value.textContent = fps;
            fpsElements.value.style.color = color;
            fpsElements.indicator.style.backgroundColor = color;

            fpsElements.avg.textContent = avg;
            fpsElements.min.textContent = min || '-';
            fpsElements.max.textContent = max || '-';

            fpsElements.frameTime.textContent = deltaMs.toFixed(2) + 'ms';
            fpsElements.target.textContent = `(${(1000 / fps || 0).toFixed(1)}ms target)`;

            // Update SVG graph
            fpsElements.linePath.setAttribute('d', generatePath(fpsHistory));
            fpsElements.linePath.setAttribute('stroke', color);
            fpsElements.areaPath.setAttribute('d', generateAreaPath(fpsHistory));
            fpsElements.gradientStop.setAttribute('stop-color', color);
        }

        // ========== EASING UTILITIES ==========
        // Attempt to compute the t value for a given x on cubic bezier curve
        // Returns x directly since we use symmetric ease curves
        function cubicBezierEase(t, p1, p2) {
            // Attempt to compute cubic bezier with control points (0,0), (p1,p1), (p2,p2), (1,1)
            // For ease-in-out this gives smooth acceleration and deceleration
            // Using approximate formula for common easing curves
            const t2 = t * t;
            const t3 = t2 * t;
            const mt = 1 - t;
            const mt2 = mt * mt;
            const mt3 = mt2 * mt;

            // Cubic bezier: B(t) = (1-t)³P0 + 3(1-t)²tP1 + 3(1-t)t²P2 + t³P3
            // With P0=0, P1=p1, P2=p2, P3=1
            return 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3;
        }

        // Ease-out: starts fast, slows down at end (good for arriving at target)
        function easeOut(t) {
            return cubicBezierEase(t, 0.0, 0.58);
        }

        // Ease-in-out: slow start, fast middle, slow end (good for smooth transitions)
        function easeInOut(t) {
            return cubicBezierEase(t, 0.42, 0.58);
        }

        // Smooth ease-out with slight overshoot feel (Material Design style)
        function easeOutSmooth(t) {
            // Deceleration curve - fast start, gentle landing
            return 1 - Math.pow(1 - t, 3);
        }

        // ========== FLOCK TRANSITION SYSTEM ==========
        // Completely separate animation system for bar transitions
        // Shapes morph from start to end shape while traveling curved paths

        class FlockTransition {
            constructor() {
                this.active = false;
                this.shapes = [];           // Shapes being animated
                this.onComplete = null;     // Callback when transition finishes
            }

            // Resample a polygon to N evenly-spaced points along its perimeter
            resamplePolygon(polygon, numPoints = 32) {
                if (!polygon || polygon.length < 3) return null;

                // Calculate total perimeter length
                let perimeter = 0;
                const segmentLengths = [];
                for (let i = 0; i < polygon.length; i++) {
                    const curr = polygon[i];
                    const next = polygon[(i + 1) % polygon.length];
                    const len = Math.sqrt((next[0] - curr[0]) ** 2 + (next[1] - curr[1]) ** 2);
                    segmentLengths.push(len);
                    perimeter += len;
                }

                // Sample points evenly along perimeter
                const result = [];
                const stepLen = perimeter / numPoints;
                let accumulated = 0;
                let segIdx = 0;
                let segProgress = 0;

                for (let i = 0; i < numPoints; i++) {
                    const targetDist = i * stepLen;

                    // Advance to the right segment
                    while (accumulated + segmentLengths[segIdx] < targetDist && segIdx < polygon.length - 1) {
                        accumulated += segmentLengths[segIdx];
                        segIdx++;
                    }

                    // Interpolate within segment
                    const remainingDist = targetDist - accumulated;
                    const segLen = segmentLengths[segIdx];
                    const t = segLen > 0 ? remainingDist / segLen : 0;

                    const curr = polygon[segIdx];
                    const next = polygon[(segIdx + 1) % polygon.length];
                    result.push([
                        curr[0] + t * (next[0] - curr[0]),
                        curr[1] + t * (next[1] - curr[1])
                    ]);
                }

                return result;
            }

            // Compute Voronoi polygon for a single cell given all seed positions
            computeCellPolygon(cellIdx, seedPositions, zoneBounds) {
                const cell = seedPositions[cellIdx];
                let polygon = zoneBounds.map(p => [...p]);

                for (let j = 0; j < seedPositions.length; j++) {
                    if (cellIdx === j) continue;
                    const other = seedPositions[j];

                    const dx = other.x - cell.x;
                    const dy = other.y - cell.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 0.001) continue;

                    const midX = (cell.x + other.x) / 2;
                    const midY = (cell.y + other.y) / 2;
                    const nx = cell.x - other.x;
                    const ny = cell.y - other.y;

                    polygon = clipPolygon(polygon, midX, midY, nx, ny);
                    if (polygon.length < 3) break;
                }

                return polygon.length >= 3 ? polygon : null;
            }

            // Start a flock transition
            start(cells, targetPositions, onComplete) {
                console.log('FlockTransition.start() called with', cells.length, 'cells');
                this.active = true;
                this.onComplete = onComplete;
                this.shapes = [];

                const RESAMPLE_POINTS = 32; // Number of points for polygon interpolation

                // Get target zone bounds (config is already set to target values)
                const targetZone = getZoneBounds(true);
                const gap = config.gap; // Gap for inset

                // Calculate group centers for direction
                // Use DISPLACED positions for start (matches displayPolygon)
                let startCenterX = 0, startCenterY = 0;
                let targetCenterX = 0, targetCenterY = 0;

                cells.forEach((cell, i) => {
                    startCenterX += cell.displacedX;
                    startCenterY += cell.displacedY;
                    targetCenterX += targetPositions[i].x;
                    targetCenterY += targetPositions[i].y;
                });
                startCenterX /= cells.length;
                startCenterY /= cells.length;
                targetCenterX /= cells.length;
                targetCenterY /= cells.length;

                // Overall transition direction
                const dirX = targetCenterX - startCenterX;
                const dirY = targetCenterY - startCenterY;
                const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
                const normDirX = dirLen > 1 ? dirX / dirLen : 0;
                const normDirY = dirLen > 1 ? dirY / dirLen : 1;
                const perpX = -normDirY;
                const perpY = normDirX;

                // Find max radius for normalization (use displaced positions)
                let maxRadius = 0;
                cells.forEach(cell => {
                    const dx = cell.displacedX - startCenterX;
                    const dy = cell.displacedY - startCenterY;
                    maxRadius = Math.max(maxRadius, Math.sqrt(dx * dx + dy * dy));
                });

                // Create shapes with morphing polygons
                cells.forEach((cell, i) => {
                    const target = targetPositions[i];

                    // START polygon: current display polygon (already has gap inset)
                    const startPolygonRaw = cell.displayPolygon ?
                        cell.displayPolygon.map(p => [...p]) : null;

                    if (!startPolygonRaw || startPolygonRaw.length < 3) {
                        console.log('Cell', i, 'has no displayPolygon');
                        return;
                    }

                    // END polygon: compute what it will look like at target position
                    let endPolygonRaw = this.computeCellPolygon(i, targetPositions, targetZone.bounds);

                    if (!endPolygonRaw || endPolygonRaw.length < 3) {
                        console.log('Cell', i, 'has no target polygon');
                        return;
                    }

                    // Apply gap inset to target polygon (same as displayPolygon gets)
                    if (gap > 0) {
                        endPolygonRaw = insetPolygon(endPolygonRaw, gap / 2);
                        if (!endPolygonRaw || endPolygonRaw.length < 3) {
                            console.log('Cell', i, 'target polygon collapsed after inset');
                            return;
                        }
                    }

                    // Use DISPLACED position as start (matches displayPolygon)
                    const startX = cell.displacedX;
                    const startY = cell.displacedY;
                    const targetX = target.x;
                    const targetY = target.y;

                    // Convert polygons to relative coordinates (relative to their seed)
                    // This way we can interpolate shape independently of position
                    const startRelative = startPolygonRaw.map(p => [p[0] - startX, p[1] - startY]);
                    const endRelative = endPolygonRaw.map(p => [p[0] - targetX, p[1] - targetY]);

                    // Resample both polygons to same number of points for smooth interpolation
                    const startResampled = this.resamplePolygon(startRelative, RESAMPLE_POINTS);
                    const endResampled = this.resamplePolygon(endRelative, RESAMPLE_POINTS);

                    if (!startResampled || !endResampled) {
                        console.log('Cell', i, 'resample failed');
                        return;
                    }

                    // Path calculations
                    const pathDx = targetX - startX;
                    const pathDy = targetY - startY;
                    const pathLen = Math.sqrt(pathDx * pathDx + pathDy * pathDy);

                    // Position relative to group center
                    const toCellX = startX - startCenterX;
                    const toCellY = startY - startCenterY;

                    // Project onto perpendicular axis (left/right of movement)
                    const perpPosition = toCellX * perpX + toCellY * perpY;
                    const perpNormalized = maxRadius > 0 ? perpPosition / maxRadius : 0;

                    // Project onto movement direction (front/back of group)
                    const frontPosition = toCellX * normDirX + toCellY * normDirY;
                    const frontNormalized = maxRadius > 0 ? frontPosition / maxRadius : 0;

                    // Curve calculation
                    const edgeFactor = Math.abs(perpNormalized);
                    const curveDirection = perpNormalized >= 0 ? 1 : -1;
                    const curveAmount = edgeFactor * edgeFactor * maxRadius * 1.5;

                    const midX = (startX + targetX) / 2;
                    const midY = (startY + targetY) / 2;
                    const controlX = midX + perpX * curveAmount * curveDirection;
                    const controlY = midY + perpY * curveAmount * curveDirection;

                    // Stagger: back cells go first
                    const departureDelay = (frontNormalized + 1) / 2 * 1.5;

                    // Curve length estimation
                    const startToControl = Math.sqrt((controlX - startX) ** 2 + (controlY - startY) ** 2);
                    const controlToEnd = Math.sqrt((targetX - controlX) ** 2 + (targetY - controlY) ** 2);
                    const curveLen = (pathLen + startToControl + controlToEnd) / 2;

                    // Calculate bounding radius from start polygon
                    const boundingRadius = Math.max(...startPolygonRaw.map(p =>
                        Math.sqrt((p[0] - startX) ** 2 + (p[1] - startY) ** 2)
                    ));

                    this.shapes.push({
                        index: i,
                        // Morphing polygons (relative to seed position)
                        startPolygon: startResampled,
                        endPolygon: endResampled,
                        pattern: cell.pattern,
                        color: cell.color,
                        opacity: 1.0,

                        startX, startY,
                        currentX: startX,
                        currentY: startY,
                        targetX, targetY,
                        controlX, controlY,

                        pathLen: curveLen,
                        progress: 0,
                        departureDelay,
                        waitTime: departureDelay,
                        arrived: false,
                        boundingRadius,
                        cellIndex: cell.index
                    });
                });

                console.log('FlockTransition created', this.shapes.length, 'shapes');
            }

            // Update the flock transition (called each frame)
            update(dt) {
                if (!this.active) return false;

                const speed = 200; // pixels per second (slower for visible curves)
                const arrivalThreshold = 2;
                const frameTime = Math.min(dt * 16, 50) / 1000; // seconds

                let allArrived = true;

                for (const shape of this.shapes) {
                    if (shape.arrived) continue;

                    // Handle departure delay (staggering)
                    if (shape.waitTime > 0) {
                        shape.waitTime -= frameTime;
                        allArrived = false;
                        continue;
                    }

                    // Advance progress based on speed and path length
                    const progressStep = (speed * frameTime) / shape.pathLen;
                    shape.progress = Math.min(1, shape.progress + progressStep);

                    if (shape.progress >= 1) {
                        shape.currentX = shape.targetX;
                        shape.currentY = shape.targetY;
                        shape.arrived = true;
                    } else {
                        allArrived = false;

                        // Apply ease-in-out for natural movement
                        // Accelerate at start, decelerate at end
                        const t = shape.progress;
                        const eased = t < 0.5
                            ? 2 * t * t
                            : 1 - Math.pow(-2 * t + 2, 2) / 2;

                        // Quadratic Bezier position with eased t
                        const oneMinusT = 1 - eased;
                        shape.currentX = oneMinusT * oneMinusT * shape.startX +
                                        2 * oneMinusT * eased * shape.controlX +
                                        eased * eased * shape.targetX;
                        shape.currentY = oneMinusT * oneMinusT * shape.startY +
                                        2 * oneMinusT * eased * shape.controlY +
                                        eased * eased * shape.targetY;
                    }
                }

                // Collision avoidance
                this.resolveCollisions();

                if (allArrived) {
                    console.log('All shapes arrived - completing transition');
                    this.complete();
                    return false;
                }

                return true;
            }

            // Resolve collisions between shapes
            resolveCollisions() {
                const minSeparation = 20; // Minimum gap between shapes
                const iterations = 3;     // Multiple passes for stability

                for (let iter = 0; iter < iterations; iter++) {
                    for (let i = 0; i < this.shapes.length; i++) {
                        const shapeA = this.shapes[i];
                        if (shapeA.arrived) continue;

                        for (let j = i + 1; j < this.shapes.length; j++) {
                            const shapeB = this.shapes[j];
                            if (shapeB.arrived) continue;

                            // Quick bounding check
                            const dx = shapeB.currentX - shapeA.currentX;
                            const dy = shapeB.currentY - shapeA.currentY;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const minDist = shapeA.boundingRadius + shapeB.boundingRadius + minSeparation;

                            if (dist < minDist && dist > 0.1) {
                                // Collision! Push shapes apart
                                const overlap = minDist - dist;
                                const pushX = (dx / dist) * overlap * 0.5;
                                const pushY = (dy / dist) * overlap * 0.5;

                                // Weight by progress - shapes further along yield less
                                const weightA = 1 - shapeA.progress * 0.5;
                                const weightB = 1 - shapeB.progress * 0.5;
                                const totalWeight = weightA + weightB;

                                if (totalWeight > 0) {
                                    shapeA.currentX -= pushX * (weightA / totalWeight);
                                    shapeA.currentY -= pushY * (weightA / totalWeight);
                                    shapeB.currentX += pushX * (weightB / totalWeight);
                                    shapeB.currentY += pushY * (weightB / totalWeight);
                                }
                            }
                        }
                    }
                }
            }

            // Complete the transition
            complete() {
                this.active = false;
                if (this.onComplete) {
                    // Pass final positions back
                    const finalPositions = this.shapes.map(shape => ({
                        index: shape.cellIndex,
                        x: shape.currentX,
                        y: shape.currentY
                    }));
                    this.onComplete(finalPositions);
                }
            }

            // Get current polygon for a shape (interpolated between start and end, at current position)
            getInterpolatedPolygon(shape) {
                // Use eased progress for shape morphing too
                const t = shape.progress;
                const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

                // Interpolate each vertex between start and end polygon
                const interpolated = [];
                for (let i = 0; i < shape.startPolygon.length; i++) {
                    const startPt = shape.startPolygon[i];
                    const endPt = shape.endPolygon[i];
                    interpolated.push([
                        startPt[0] + eased * (endPt[0] - startPt[0]) + shape.currentX,
                        startPt[1] + eased * (endPt[1] - startPt[1]) + shape.currentY
                    ]);
                }
                return interpolated;
            }

            // Render all shapes during transition
            render(ctx, cornerRadius) {
                if (!this.active) return;

                console.log('FlockTransition.render() - shapes:', this.shapes.length);
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                // Sort by Y position for proper overlap (shapes lower on screen drawn later)
                const sortedShapes = [...this.shapes].sort((a, b) => a.currentY - b.currentY);

                for (const shape of sortedShapes) {
                    const polygon = this.getInterpolatedPolygon(shape);
                    if (!polygon || polygon.length < 3) continue;

                    ctx.save();
                    ctx.globalAlpha = shape.opacity;

                    // Create rounded clipping path
                    drawRoundedPolygon(ctx, polygon, cornerRadius);
                    ctx.clip();

                    // Calculate bounds
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    for (const p of polygon) {
                        minX = Math.min(minX, p[0]);
                        maxX = Math.max(maxX, p[0]);
                        minY = Math.min(minY, p[1]);
                        maxY = Math.max(maxY, p[1]);
                    }

                    const cellW = maxX - minX;
                    const cellH = maxY - minY;
                    const centerX = (minX + maxX) / 2;
                    const centerY = (minY + maxY) / 2;

                    // Draw pattern
                    if (shape.pattern) {
                        const size = Math.max(cellW, cellH) * 1.4;
                        ctx.drawImage(
                            shape.pattern,
                            centerX - size / 2,
                            centerY - size / 2,
                            size,
                            size
                        );
                    }

                    ctx.restore();

                    // Draw border
                    ctx.save();
                    drawRoundedPolygon(ctx, polygon, cornerRadius);
                    ctx.clip();
                    drawRoundedPolygon(ctx, polygon, cornerRadius);
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }

        // Global flock transition instance
        let flockTransition = new FlockTransition();

        // ========== CELL CLASS ==========
        class Cell {
            constructor(x, y, index) {
                this.index = index;
                this.baseX = x;
                this.baseY = y;
                this.x = x;
                this.y = y;

                // Parametric position along bar (0-1)
                // Used for consistent cell ordering during transitions
                this.parametricT = 0;

                // Scale animation (exponential smoothing - no resets)
                this.scale = 1.0;              // Current scale
                this.targetScale = 1.0;        // Target scale

                // Displacement animation (exponential smoothing - no resets)
                this.displacedX = x;           // Current displaced position
                this.displacedY = y;
                this.targetDisplacedX = x;     // Target displaced position
                this.targetDisplacedY = y;

                this.basePolygon = null;   // Computed once at init - NEVER changes
                this.baseCentroid = null;  // Center of base polygon
                this.polygon = null;       // For hit testing
                this.displayPolygon = null; // What gets rendered

                // Zoom animation (progress-based)
                this.zoom = config.nonHoverImageZoom;
                this.targetZoom = config.nonHoverImageZoom;
                this.zoomStart = config.nonHoverImageZoom;
                this.zoomProgress = 1.0;
                this.lastTargetZoom = config.nonHoverImageZoom;

                // Opacity animation (progress-based)
                this.opacity = config.nonHoveredOpacity;
                this.targetOpacity = config.nonHoveredOpacity;
                this.opacityStart = config.nonHoveredOpacity;
                this.opacityProgress = 1.0;
                this.lastTargetOpacity = config.nonHoveredOpacity;

                // Interaction feel
                this.hoverMix = 0; // Smoothed hover strength for outlines/bleed

                const data = cellData[index % cellData.length];
                this.title = data.title;
                this.link = data.link;
                this.color = data.color;
                this.pattern = null;
            }

            update(dt, isHovered) {
                // Exponential smoothing - smoothly chase targets without resets
                // When switching cells, just changes target - no jarring restarts
                // Note: Bar transitions are handled by FlockTransition, not here

                // === HOVER STATE SMOOTHING ===
                const targetHover = isHovered ? 1 : 0;
                const hoverRate = 1 - Math.exp(-Math.max(0.001, dt) * 0.12);
                this.hoverMix += (targetHover - this.hoverMix) * hoverRate;

                // === SCALE ANIMATION ===
                // Squared curve gives more resolution at slow speeds where differences are perceptible
                // Speed 1 = 0.01 (very slow), Speed 50 = 0.10, Speed 100 = 0.35 (fast)
                const t = config.expansionSpeed / 100;
                const scaleLerp = 0.01 + t * t * 0.34;
                this.scale += (this.targetScale - this.scale) * scaleLerp;

                // Snap when very close
                if (Math.abs(this.scale - this.targetScale) < 0.001) {
                    this.scale = this.targetScale;
                }

                // === DISPLACEMENT ANIMATION ===
                const displaceLerp = 0.01 + t * t * 0.34;
                this.displacedX += (this.targetDisplacedX - this.displacedX) * displaceLerp;
                this.displacedY += (this.targetDisplacedY - this.displacedY) * displaceLerp;

                // Snap when very close
                const distSq = Math.pow(this.displacedX - this.targetDisplacedX, 2) +
                               Math.pow(this.displacedY - this.targetDisplacedY, 2);
                if (distSq < 0.25) {
                    this.displacedX = this.targetDisplacedX;
                    this.displacedY = this.targetDisplacedY;
                }

                // === ZOOM ANIMATION ===
                if (this.targetZoom !== this.lastTargetZoom) {
                    this.zoomStart = this.zoom;
                    this.zoomProgress = 0;
                    this.lastTargetZoom = this.targetZoom;
                }

                if (this.zoomProgress < 1) {
                    // Faster zoom animation: speed 1-100 maps to ~500ms to ~50ms transition
                    const progressRate = 2 + config.imageZoomSpeed * 0.15;
                    this.zoomProgress = Math.min(1, this.zoomProgress + progressRate * dt / 1000);
                    const easedProgress = easeInOut(this.zoomProgress);
                    this.zoom = this.zoomStart + (this.targetZoom - this.zoomStart) * easedProgress;
                } else {
                    this.zoom = this.targetZoom;
                }

                // === OPACITY ANIMATION ===
                if (this.targetOpacity !== this.lastTargetOpacity) {
                    this.opacityStart = this.opacity;
                    this.opacityProgress = 0;
                    this.lastTargetOpacity = this.targetOpacity;
                }

                if (this.opacityProgress < 1) {
                    // Faster opacity animation for snappier hover response
                    const progressRate = 12; // Fast transition (~80ms to complete)
                    this.opacityProgress = Math.min(1, this.opacityProgress + progressRate * dt / 1000);
                    const easedProgress = easeInOut(this.opacityProgress);
                    this.opacity = this.opacityStart + (this.targetOpacity - this.opacityStart) * easedProgress;
                } else {
                    this.opacity = this.targetOpacity;
                }

                // Ensure hovered cells snap to full opacity quickly
                if (isHovered && this.targetOpacity === 1.0 && this.opacity > 0.95) {
                    this.opacity = 1.0;
                    this.opacityProgress = 1.0;
                }
            }

            createPattern() {
                const size = 300;
                const patternCanvas = document.createElement('canvas');
                patternCanvas.width = size;
                patternCanvas.height = size;
                const pctx = patternCanvas.getContext('2d');

                // Gradient background
                const gradient = pctx.createLinearGradient(0, 0, size, size);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(1, this.adjustColor(this.color, -40));
                pctx.fillStyle = gradient;
                pctx.fillRect(0, 0, size, size);

                // Decorative circles
                pctx.globalAlpha = 0.08;
                for (let i = 0; i < 5; i++) {
                    const cx = Math.random() * size;
                    const cy = Math.random() * size;
                    const r = 30 + Math.random() * 60;
                    pctx.beginPath();
                    pctx.arc(cx, cy, r, 0, Math.PI * 2);
                    pctx.fillStyle = '#fff';
                    pctx.fill();
                }

                // Cell number
                pctx.globalAlpha = 0.2;
                pctx.fillStyle = '#fff';
                pctx.font = `bold ${size * 0.35}px system-ui, sans-serif`;
                pctx.textAlign = 'center';
                pctx.textBaseline = 'middle';
                pctx.fillText(this.index + 1, size / 2, size / 2);

                this.pattern = patternCanvas;
            }

            adjustColor(hex, amount) {
                const num = parseInt(hex.slice(1), 16);
                const r = Math.min(255, Math.max(0, (num >> 16) + amount));
                const g = Math.min(255, Math.max(0, ((num >> 8) & 0xff) + amount));
                const b = Math.min(255, Math.max(0, (num & 0xff) + amount));
                return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
            }
        }

        // ========== TRUE EDGE-BASED VORONOI ==========
        // Edges are LINES between cells (not clipped surfaces)
        // Vertices are computed as intersections of edges
        // This ensures consistent topology and shared boundaries

        let voronoiEdges = [];      // Edges between cell pairs
        let cellEdgeMap = [];       // For each cell, list of edge indices + neighbor info

        // Helper to compute rotated zone bounds
        // The zone is a "band" that can rotate in 45° increments
        // Uses 8 discrete rulesets for reliable clipping at each angle
        // Returns { bounds: [[x,y],...], clipPlanes: [{px,py,nx,ny},...], cellBounds: {xMin,xMax,yMin,yMax} }
        function getZoneBounds(includeBuffer = false) {
            const margin = config.contentZoneEnabled ? config.contentZoneMargin : 0;
            const buffer = includeBuffer ? config.bleedBuffer : 0;

            // Calculate center with position offset
            // Position is perpendicular to bar orientation
            const rawAngle = config.contentZoneRotation;
            const snappedAngle = Math.round(rawAngle / 45) * 45 % 360;
            const rotation = snappedAngle * Math.PI / 180;

            // Position offset direction is perpendicular to the bar
            // For horizontal bar (0°): offset is vertical (up/down)
            // For vertical bar (90°): offset is horizontal (left/right)
            // For diagonal (45°): offset is horizontal (as specified by user)
            const positionOffset = config.contentZonePosition;
            let offsetX = 0, offsetY = 0;

            const normalizedAngle = ((snappedAngle % 180) + 180) % 180;
            if (normalizedAngle === 0) {
                // Horizontal bar - offset vertically
                offsetY = positionOffset * (height / 2) * 0.8;
            } else if (normalizedAngle === 90) {
                // Vertical bar - offset horizontally
                offsetX = positionOffset * (width / 2) * 0.8;
            } else {
                // Diagonal bars - offset horizontally (screen is wide)
                offsetX = positionOffset * (width / 2) * 0.8;
            }

            const cx = width / 2 + offsetX;
            const cy = height / 2 + offsetY;

            const cos = Math.cos(rotation);
            const sin = Math.sin(rotation);

            // Band length: screen diagonal ensures full coverage at any angle
            const diagonal = Math.sqrt(width * width + height * height);
            const halfLength = diagonal / 2 + buffer;

            // Band thickness depends on angle sector
            // 0°/180°: use height, 90°/270°: use width, 45°/135°/225°/315°: use diagonal blend
            let effectiveSize;
            // normalizedAngle already computed above for position offset

            if (normalizedAngle === 0) {
                // Horizontal band
                effectiveSize = height;
            } else if (normalizedAngle === 90) {
                // Vertical band
                effectiveSize = width;
            } else {
                // Diagonal bands (45°, 135°)
                // For diagonals, use the smaller dimension to maintain reasonable thickness
                effectiveSize = Math.min(width, height) * 1.2;
            }

            const halfThickness = (effectiveSize / 2) * (1 - margin) + buffer;

            // Create band rectangle in local coords (length along X, thickness along Y)
            const localCorners = [
                [-halfLength, -halfThickness],
                [halfLength, -halfThickness],
                [halfLength, halfThickness],
                [-halfLength, halfThickness]
            ];

            // Rotate and translate to screen center
            const corners = localCorners.map(([lx, ly]) => [
                cx + lx * cos - ly * sin,
                cy + lx * sin + ly * cos
            ]);

            // Build clip planes with correct inward normals for each edge
            // Edge order: top, right, bottom, left (in rotated space)
            // Normals must point INTO the rectangle
            const clipPlanes = [];

            // For each edge, compute the inward-pointing normal
            // The rectangle winds CW in screen coords, so inward is to the LEFT of edge direction
            for (let i = 0; i < 4; i++) {
                const p1 = corners[i];
                const p2 = corners[(i + 1) % 4];
                const ex = p2[0] - p1[0];
                const ey = p2[1] - p1[1];
                const len = Math.sqrt(ex * ex + ey * ey);
                if (len < 0.001) continue;

                // For CW winding, inward normal is (ey, -ex) / len
                // For CCW winding, inward normal is (-ey, ex) / len
                // Our corners are defined CCW in local space, but screen Y is inverted...
                // Let's verify by checking if center is on positive side
                const midX = (p1[0] + p2[0]) / 2;
                const midY = (p1[1] + p2[1]) / 2;

                // Try one normal direction
                let nx = -ey / len;
                let ny = ex / len;

                // Check if center is on positive side (inside)
                const centerDist = (cx - midX) * nx + (cy - midY) * ny;
                if (centerDist < 0) {
                    // Wrong direction, flip it
                    nx = -nx;
                    ny = -ny;
                }

                clipPlanes.push({ px: midX, py: midY, nx, ny });
            }

            // Cell generation bounds - shrink from zone for seed placement
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const [x, y] of corners) {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }

            const cellBounds = {
                xMin: Math.max(40, minX + 60),
                xMax: Math.min(width - 40, maxX - 60),
                yMin: Math.max(40, minY + 60),
                yMax: Math.min(height - 40, maxY - 60)
            };

            return { bounds: corners, clipPlanes, cellBounds, snappedAngle };
        }

        function computeBaseVoronoi() {
            const zone = getZoneBounds(true);
            const buffer = config.bleedBuffer;

            // Build edges between all cell pairs
            voronoiEdges = [];
            cellEdgeMap = cells.map(() => []);

            for (let i = 0; i < cells.length; i++) {
                for (let j = i + 1; j < cells.length; j++) {
                    const cellA = cells[i];
                    const cellB = cells[j];

                    const dx = cellB.baseX - cellA.baseX;
                    const dy = cellB.baseY - cellA.baseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 0.001) continue;

                    const edgeIdx = voronoiEdges.length;

                    // Edge as a LINE: point on line (midpoint) + direction (perpendicular to cell-cell line)
                    const midX = (cellA.baseX + cellB.baseX) / 2;
                    const midY = (cellA.baseY + cellB.baseY) / 2;

                    // Edge direction (along the edge, perpendicular to cell-cell)
                    const edgeDirX = -dy / dist;
                    const edgeDirY = dx / dist;

                    // Normal pointing from B toward A
                    const nx = -dx / dist;
                    const ny = -dy / dist;

                    voronoiEdges.push({
                        cellA: i,
                        cellB: j,
                        midX, midY,
                        dirX: edgeDirX,
                        dirY: edgeDirY,
                        nx, ny,
                        dist
                    });

                    // Map edges to cells with angle for sorting
                    const angleFromA = Math.atan2(cellB.baseY - cellA.baseY, cellB.baseX - cellA.baseX);
                    const angleFromB = Math.atan2(cellA.baseY - cellB.baseY, cellA.baseX - cellB.baseX);

                    cellEdgeMap[i].push({ edgeIdx, neighborIdx: j, angle: angleFromA, side: 'A' });
                    cellEdgeMap[j].push({ edgeIdx, neighborIdx: i, angle: angleFromB, side: 'B' });
                }
            }

            // Sort each cell's edges by angle (counter-clockwise order)
            for (let i = 0; i < cells.length; i++) {
                cellEdgeMap[i].sort((a, b) => a.angle - b.angle);
            }

            // Compute base polygons for centroid reference
            // Use rotated zone bounds
            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                let polygon = zone.bounds.map(p => [...p]);

                for (let j = 0; j < cells.length; j++) {
                    if (i === j) continue;
                    const other = cells[j];
                    const dx = other.baseX - cell.baseX;
                    const dy = other.baseY - cell.baseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 0.001) continue;

                    const midX = (cell.baseX + other.baseX) / 2;
                    const midY = (cell.baseY + other.baseY) / 2;
                    const nx = cell.baseX - other.baseX;
                    const ny = cell.baseY - other.baseY;

                    polygon = clipPolygon(polygon, midX, midY, nx, ny);
                    if (polygon.length < 3) break;
                }

                cell.basePolygon = polygon.length >= 3 ? polygon : null;
                cell.baseCentroid = getPolygonCentroid(cell.basePolygon);
            }

            updateDisplayPolygons();
        }

        // Compute shifted edge as a LINE (point + direction)
        function getShiftedEdge(edge, shift) {
            return {
                // Point on the shifted line
                px: edge.midX + edge.nx * shift,
                py: edge.midY + edge.ny * shift,
                // Direction along the edge (unchanged)
                dx: edge.dirX,
                dy: edge.dirY,
                // Normal (unchanged)
                nx: edge.nx,
                ny: edge.ny
            };
        }

        // Intersect two lines, each defined by point (px,py) and direction (dx,dy)
        function intersectLines(line1, line2) {
            const denom = line1.dx * line2.dy - line1.dy * line2.dx;
            if (Math.abs(denom) < 0.0001) return null; // Parallel

            const t = ((line2.px - line1.px) * line2.dy - (line2.py - line1.py) * line2.dx) / denom;
            return [line1.px + t * line1.dx, line1.py + t * line1.dy];
        }

        // Compute and constrain displacement targets BEFORE Cell.update runs
        // This ensures animation never chases invalid positions that would cause concaves
        function computeDisplacementTargets() {
            // Constraint constants
            const minSeedSeparation = 48;
            const minBisectorDist = 15;
            const maxIterations = 3;
            const safetyBuffer = 30;

            // Compute TARGET displaced positions based on hovered cell
            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];

                // Default: return to base position
                cell.targetDisplacedX = cell.baseX;
                cell.targetDisplacedY = cell.baseY;

                // If no cell is hovered, all targets are base position
                if (hoveredCell < 0 || i === hoveredCell) {
                    continue;
                }

                // Push this seed away from the hovered cell
                const hovered = cells[hoveredCell];
                const dx = cell.baseX - hovered.baseX;
                const dy = cell.baseY - hovered.baseY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 1) continue;

                // Use the HOVERED cell's TARGET scale so neighbors get their final
                // (constrained) target positions immediately. Both hover scale and
                // neighbor displacement animate at the same rate (expansionSpeed),
                // keeping them visually in sync. Using current scale causes constant
                // animation restarts as targets change each frame by >0.5px.
                const scaleExtra = Math.max(0, hovered.targetScale - 1.0);

                // Distance-based falloff to keep far cells calmer/supple
                const falloff = Math.exp(-(dist * dist) / (2 * config.displaceFalloff * config.displaceFalloff));

                // Neighbors move effortlessly - no artificial friction
                const pushAmount = scaleExtra * config.maxExpansion * config.displaceRatio * falloff;

                cell.targetDisplacedX = cell.baseX + (dx / dist) * pushAmount;
                cell.targetDisplacedY = cell.baseY + (dy / dist) * pushAmount;
            }
            // No artificial constraints - neighbors move effortlessly
        }

        // Display polygons with neighbor displacement via seed movement
        // Moving seeds recomputes Voronoi naturally while maintaining perfect tessellation
        // Note: Bar transitions are handled by FlockTransition system with its own render
        function updateDisplayPolygons() {
            const zone = getZoneBounds(false);
            const zoneWithBuffer = getZoneBounds(true);
            const gap = config.gap;

            // Build array for Voronoi computation from current animated positions
            const displacedSeeds = cells.map(cell => ({
                x: cell.displacedX,
                y: cell.displacedY
            }));

            // Rebuild Voronoi polygons using displaced seeds - no constraints, effortless
            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                const seed = displacedSeeds[i];

                // Start with rotated zone bounds (with buffer)
                let polygon = zoneWithBuffer.bounds.map(p => [...p]);

                // Clip against bisector with each other cell (using displaced seeds)
                for (let j = 0; j < cells.length; j++) {
                    if (i === j) continue;

                    const other = displacedSeeds[j];
                    const dx = other.x - seed.x;
                    const dy = other.y - seed.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 0.001) continue;

                    // Midpoint between displaced seeds
                    const mx = (seed.x + other.x) / 2;
                    const my = (seed.y + other.y) / 2;

                    // Normal pointing toward this cell
                    const nx = -dx / dist;
                    const ny = -dy / dist;

                    polygon = clipPolygon(polygon, mx, my, nx, ny);
                    if (polygon.length < 3) break;
                }

                if (polygon.length < 3) {
                    cell.polygon = cell.basePolygon;
                    cell.displayPolygon = cell.basePolygon;
                    continue;
                }

                // Compute centroid and validate polygon integrity
                const centroid = getPolygonCentroid(polygon);

                // Check polygon area - if it's too small or negative, cell is over-deformed
                let polygonArea = 0;
                for (let k = 0; k < polygon.length; k++) {
                    const k1 = (k + 1) % polygon.length;
                    polygonArea += polygon[k][0] * polygon[k1][1];
                    polygonArea -= polygon[k1][0] * polygon[k][1];
                }
                polygonArea = polygonArea / 2;

                // Get base polygon area for comparison
                let baseArea = 0;
                if (cell.basePolygon) {
                    for (let k = 0; k < cell.basePolygon.length; k++) {
                        const k1 = (k + 1) % cell.basePolygon.length;
                        baseArea += cell.basePolygon[k][0] * cell.basePolygon[k1][1];
                        baseArea -= cell.basePolygon[k1][0] * cell.basePolygon[k][1];
                    }
                    baseArea = Math.abs(baseArea / 2);
                }

                // CRITICAL: If centroid is outside polygon OR area collapsed too much,
                // the cell has flipped inside-out or been over-squeezed
                const minAreaRatio = 0.1; // Don't let cell shrink below 10% of original
                const warnAreaRatio = 0.3; // Start blending toward base below 30%
                const isInverted = polygonArea < 0;
                const isTooSmall = baseArea > 0 && Math.abs(polygonArea) < baseArea * minAreaRatio;
                const centroidEscaped = !pointInPolygon(centroid.x, centroid.y, polygon);

                if (isInverted || isTooSmall || centroidEscaped) {
                    // Deformation limit reached - use base polygon
                    cell.baseCentroid = getPolygonCentroid(cell.basePolygon);
                    cell.polygon = cell.basePolygon;
                    cell.displayPolygon = cell.basePolygon;
                    continue;
                }

                // Smooth recovery: blend toward base when area is getting small
                // This prevents jarring snaps by gradually returning to safe shape
                const areaRatio = baseArea > 0 ? Math.abs(polygonArea) / baseArea : 1;
                if (areaRatio < warnAreaRatio && cell.basePolygon && polygon.length === cell.basePolygon.length) {
                    // Blend factor: 0 at warnAreaRatio, 1 at minAreaRatio
                    const blendRange = warnAreaRatio - minAreaRatio;
                    const blendFactor = Math.min(1, (warnAreaRatio - areaRatio) / blendRange);

                    // Interpolate each vertex toward base polygon
                    for (let v = 0; v < polygon.length; v++) {
                        polygon[v][0] = polygon[v][0] * (1 - blendFactor) + cell.basePolygon[v][0] * blendFactor;
                        polygon[v][1] = polygon[v][1] * (1 - blendFactor) + cell.basePolygon[v][1] * blendFactor;
                    }
                }

                cell.baseCentroid = centroid;

                // Hit detection uses BASE polygon (stable, doesn't change with animation)
                // This prevents hover fighting when polygons shift
                cell.polygon = cell.basePolygon;

                // Clip to display bounds - INTERPOLATE buffer for smooth protrusion
                // Protrusion now follows scale animation speed (not hoverMix which is instant)
                // This ensures protrusion, expansion, and displacement all animate at the same rate
                const scaleExtra = Math.max(0, cell.scale - 1.0);
                const maxScaleExtra = config.maxExpansion / 300;

                // Calculate expansion fraction from actual scale (follows animation speed)
                const expansionFraction = maxScaleExtra > 0 ? Math.min(1, scaleExtra / maxScaleExtra) : 0;

                // Compute consistent buffer fraction for direct neighbors to prevent overlap
                // All direct neighbors must use the SAME buffer fraction so their zone clipping
                // is consistent and Voronoi boundaries between them remain aligned
                let neighborBufferFraction = 0;
                if (hoveredCell >= 0) {
                    const hoveredScale = cells[hoveredCell].scale;
                    const hoveredExpansionFactor = maxScaleExtra > 0 ? Math.max(0, hoveredScale - 1.0) / maxScaleExtra : 0;
                    // All direct neighbors get the same buffer based on hovered cell's expansion
                    neighborBufferFraction = hoveredExpansionFactor * 0.8 * 0.5; // 0.8 stress * 0.5 maxStressBuffer
                }

                // Buffer fraction based purely on animated scale - no special cases
                // This ensures smooth transitions when hover state changes
                // The 0.9 multiplier for non-hovered cells caused instant jumps
                const bufferFraction = expansionFraction;

                let clipped = polygon;
                for (let p = 0; p < zone.clipPlanes.length; p++) {
                    const inner = zone.clipPlanes[p];
                    const outer = zoneWithBuffer.clipPlanes[p];

                    // Interpolate plane position for smooth protrusion animation
                    const px = inner.px + (outer.px - inner.px) * bufferFraction;
                    const py = inner.py + (outer.py - inner.py) * bufferFraction;

                    clipped = clipPolygon(clipped, px, py, inner.nx, inner.ny);
                    if (clipped.length < 3) break;
                }

                // Apply uniform gap inset
                cell.displayPolygon = gap > 0 && clipped.length >= 3 ? insetPolygon(clipped, gap / 2) : clipped;

                // CRITICAL: Validate centroid against FINAL displayPolygon, not the pre-clipped polygon
                // The displayPolygon can be much smaller after clipping to bounds and gap inset
                if (cell.displayPolygon && cell.displayPolygon.length >= 3) {
                    if (!pointInPolygon(cell.baseCentroid.x, cell.baseCentroid.y, cell.displayPolygon)) {
                        // Centroid escaped the displayPolygon - use displayPolygon's centroid instead
                        const displayCentroid = getPolygonCentroid(cell.displayPolygon);

                        // Extra safety: if even displayPolygon's centroid is outside (concave polygon),
                        // fall back to the displaced seed position which must be inside the Voronoi cell
                        if (pointInPolygon(displayCentroid.x, displayCentroid.y, cell.displayPolygon)) {
                            cell.baseCentroid = displayCentroid;
                        } else {
                            // Use displaced seed as ultimate fallback
                            cell.baseCentroid = { x: cell.displacedX, y: cell.displacedY };
                        }
                    }
                }
            }
        }

        function clipPolygon(polygon, px, py, nx, ny) {
            const output = [];
            const n = polygon.length;

            for (let i = 0; i < n; i++) {
                const curr = polygon[i];
                const next = polygon[(i + 1) % n];

                const currDist = (curr[0] - px) * nx + (curr[1] - py) * ny;
                const nextDist = (next[0] - px) * nx + (next[1] - py) * ny;

                if (currDist >= 0) {
                    output.push(curr);
                    if (nextDist < 0) {
                        output.push(lineIntersect(curr, next, px, py, nx, ny));
                    }
                } else if (nextDist >= 0) {
                    output.push(lineIntersect(curr, next, px, py, nx, ny));
                }
            }

            return output;
        }

        function lineIntersect(a, b, px, py, nx, ny) {
            const dx = b[0] - a[0];
            const dy = b[1] - a[1];
            const denom = dx * nx + dy * ny;
            if (Math.abs(denom) < 0.0001) return [...a];
            const t = ((px - a[0]) * nx + (py - a[1]) * ny) / denom;
            return [a[0] + t * dx, a[1] + t * dy];
        }

        function getPolygonCentroid(polygon) {
            if (!polygon || polygon.length < 3) return { x: 0, y: 0 };
            let cx = 0, cy = 0;
            for (const p of polygon) {
                cx += p[0];
                cy += p[1];
            }
            return { x: cx / polygon.length, y: cy / polygon.length };
        }

        // Proper polygon inset - offset each edge inward by amount, then find new vertices
        // This creates uniform gaps between adjacent cells
        function insetPolygon(polygon, amount) {
            if (!polygon || polygon.length < 3 || amount <= 0) return polygon;

            const n = polygon.length;

            // Compute signed area to determine winding direction
            let signedArea = 0;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                signedArea += polygon[i][0] * polygon[j][1];
                signedArea -= polygon[j][0] * polygon[i][1];
            }
            // In screen coords (Y down): signedArea > 0 means CW, < 0 means CCW
            // For CW polygon, interior is on RIGHT of edge direction
            // For CCW polygon, interior is on LEFT of edge direction
            const windingSign = signedArea > 0 ? -1 : 1;

            const insetEdges = [];

            // For each edge, compute the inward-offset line
            for (let i = 0; i < n; i++) {
                const p1 = polygon[i];
                const p2 = polygon[(i + 1) % n];

                // Edge direction
                const edx = p2[0] - p1[0];
                const edy = p2[1] - p1[1];
                const len = Math.sqrt(edx * edx + edy * edy);

                if (len < 0.001) continue;

                // Inward normal - perpendicular to edge, direction depends on winding
                // For CCW: inward is to the right of edge direction (dy, -dx)
                // For CW: inward is to the left of edge direction (-dy, dx)
                const nx = windingSign * edy / len;
                const ny = windingSign * -edx / len;

                // Offset the edge inward
                const offsetP1 = [p1[0] + nx * amount, p1[1] + ny * amount];
                const offsetP2 = [p2[0] + nx * amount, p2[1] + ny * amount];

                insetEdges.push({ p1: offsetP1, p2: offsetP2, nx, ny });
            }

            if (insetEdges.length < 3) return polygon;

            // Compute new vertices as intersections of consecutive offset edges
            const result = [];
            for (let i = 0; i < insetEdges.length; i++) {
                const e1 = insetEdges[i];
                const e2 = insetEdges[(i + 1) % insetEdges.length];

                // Find intersection of two lines
                const intersection = lineLineIntersect(e1.p1, e1.p2, e2.p1, e2.p2);
                if (intersection) {
                    result.push(intersection);
                }
            }

            // Validate result - check if polygon collapsed or inverted
            if (result.length < 3) return polygon;

            // Check that result area is smaller than original (sanity check)
            let resultArea = 0;
            for (let i = 0; i < result.length; i++) {
                const j = (i + 1) % result.length;
                resultArea += result[i][0] * result[j][1];
                resultArea -= result[j][0] * result[i][1];
            }
            resultArea = Math.abs(resultArea);
            const origArea = Math.abs(signedArea);

            // If result is larger than original or collapsed to nothing, return original
            if (resultArea > origArea * 1.1 || resultArea < 1) return polygon;

            return result;
        }

        // Line-line intersection helper
        function lineLineIntersect(p1, p2, p3, p4) {
            const x1 = p1[0], y1 = p1[1];
            const x2 = p2[0], y2 = p2[1];
            const x3 = p3[0], y3 = p3[1];
            const x4 = p4[0], y4 = p4[1];

            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 0.0001) {
                // Lines are parallel, return midpoint of shared region
                return [(p2[0] + p3[0]) / 2, (p2[1] + p3[1]) / 2];
            }

            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            return [x1 + t * (x2 - x1), y1 + t * (y2 - y1)];
        }

        // Simple rect clipping
        function clipToRect(polygon, left, top, right, bottom) {
            if (!polygon || polygon.length < 3) return polygon;

            let result = polygon;
            result = clipPolygon(result, left, top, 1, 0);      // left
            result = clipPolygon(result, right, top, -1, 0);    // right
            result = clipPolygon(result, left, top, 0, 1);      // top
            result = clipPolygon(result, left, bottom, 0, -1);  // bottom

            return result;
        }

        // ========== POLYGON SIMPLIFICATION ==========
        // Removes nearly-collinear vertices and merges close points
        // This helps corner rounding work better on clipped polygons
        // More aggressive simplification: larger minEdgeLength, stricter collinearity
        function simplifyPolygon(polygon, minEdgeLength = 20, collinearThreshold = 0.95) {
            if (!polygon || polygon.length < 3) return polygon;

            // First pass: merge vertices that are too close together
            let simplified = [];
            for (let i = 0; i < polygon.length; i++) {
                const curr = polygon[i];
                const last = simplified[simplified.length - 1];

                if (!last) {
                    simplified.push(curr);
                    continue;
                }

                const dist = Math.sqrt((curr[0] - last[0]) ** 2 + (curr[1] - last[1]) ** 2);
                if (dist >= minEdgeLength) {
                    simplified.push(curr);
                } else {
                    // Merge: keep the midpoint
                    simplified[simplified.length - 1] = [(curr[0] + last[0]) / 2, (curr[1] + last[1]) / 2];
                }
            }

            // Check first and last vertex distance
            if (simplified.length > 2) {
                const first = simplified[0];
                const last = simplified[simplified.length - 1];
                const dist = Math.sqrt((first[0] - last[0]) ** 2 + (first[1] - last[1]) ** 2);
                if (dist < minEdgeLength) {
                    simplified[0] = [(first[0] + last[0]) / 2, (first[1] + last[1]) / 2];
                    simplified.pop();
                }
            }

            if (simplified.length < 3) return polygon;

            // Second pass: remove nearly-collinear points
            const result = [];
            const n = simplified.length;

            for (let i = 0; i < n; i++) {
                const prev = simplified[(i - 1 + n) % n];
                const curr = simplified[i];
                const next = simplified[(i + 1) % n];

                // Calculate vectors
                const v1x = curr[0] - prev[0];
                const v1y = curr[1] - prev[1];
                const v2x = next[0] - curr[0];
                const v2y = next[1] - curr[1];

                const len1 = Math.sqrt(v1x * v1x + v1y * v1y);
                const len2 = Math.sqrt(v2x * v2x + v2y * v2y);

                if (len1 < 0.001 || len2 < 0.001) {
                    continue; // Skip degenerate edges
                }

                // Dot product of normalized vectors
                const dot = (v1x * v2x + v1y * v2y) / (len1 * len2);

                // If vectors are nearly parallel (dot close to 1), skip this vertex
                if (dot < collinearThreshold) {
                    result.push(curr);
                }
            }

            return result.length >= 3 ? result : polygon;
        }

        // ========== ROUNDED CORNERS ==========
        function drawRoundedPolygon(ctx, polygon, radius) {
            if (!polygon || polygon.length < 3) return;

            // Calculate polygon area to detect degenerate cases
            let area = 0;
            for (let i = 0; i < polygon.length; i++) {
                const j = (i + 1) % polygon.length;
                area += polygon[i][0] * polygon[j][1];
                area -= polygon[j][0] * polygon[i][1];
            }
            area = Math.abs(area) / 2;

            // If polygon is too small, just draw it without rounding
            if (area < 100 || radius <= 0) {
                ctx.beginPath();
                ctx.moveTo(polygon[0][0], polygon[0][1]);
                for (let i = 1; i < polygon.length; i++) {
                    ctx.lineTo(polygon[i][0], polygon[i][1]);
                }
                ctx.closePath();
                return;
            }

            const n = polygon.length;

            // Pre-calculate all corner radii to ensure consistency
            const radii = [];
            for (let i = 0; i < n; i++) {
                const prev = polygon[(i - 1 + n) % n];
                const curr = polygon[i];
                const next = polygon[(i + 1) % n];

                const dist1 = Math.sqrt((prev[0] - curr[0]) ** 2 + (prev[1] - curr[1]) ** 2);
                const dist2 = Math.sqrt((next[0] - curr[0]) ** 2 + (next[1] - curr[1]) ** 2);

                // Limit radius to 50% of the shorter edge - allows corners to meet at edge midpoints
                // arcTo() handles overflow gracefully, so this is safe even for tight corners
                const maxRadius = Math.min(dist1, dist2) * 0.5;

                // Additional clamp based on interior angle to prevent concave "folds" when
                // radius exceeds available corner wedge
                const v1x = prev[0] - curr[0];
                const v1y = prev[1] - curr[1];
                const v2x = next[0] - curr[0];
                const v2y = next[1] - curr[1];
                const len1 = Math.sqrt(v1x * v1x + v1y * v1y) || 1;
                const len2 = Math.sqrt(v2x * v2x + v2y * v2y) || 1;
                const dot = (v1x * v2x + v1y * v2y) / (len1 * len2);
                const clampedDot = Math.min(1, Math.max(-1, dot));
                const interiorAngle = Math.acos(clampedDot);
                const angleLimiter = Math.tan(interiorAngle / 2);
                const maxByAngle = Math.min(dist1, dist2) * angleLimiter;

                radii[i] = Math.max(0, Math.min(radius, maxRadius, maxByAngle));
            }

            ctx.beginPath();

            // Find first valid starting point
            let started = false;
            for (let i = 0; i < n; i++) {
                const prev = polygon[(i - 1 + n) % n];
                const curr = polygon[i];
                const next = polygon[(i + 1) % n];
                const r = radii[i];

                let dx1 = prev[0] - curr[0];
                let dy1 = prev[1] - curr[1];
                let dx2 = next[0] - curr[0];
                let dy2 = next[1] - curr[1];

                const dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

                if (r < 0.5 || dist1 < 0.5 || dist2 < 0.5) {
                    // Sharp corner - no rounding
                    if (!started) {
                        ctx.moveTo(curr[0], curr[1]);
                        started = true;
                    } else {
                        ctx.lineTo(curr[0], curr[1]);
                    }
                } else {
                    // Normalize
                    dx1 /= dist1; dy1 /= dist1;
                    dx2 /= dist2; dy2 /= dist2;

                    // Points where the arc starts and ends
                    const startX = curr[0] + dx1 * r;
                    const startY = curr[1] + dy1 * r;
                    const endX = curr[0] + dx2 * r;
                    const endY = curr[1] + dy2 * r;

                    if (!started) {
                        ctx.moveTo(startX, startY);
                        started = true;
                    } else {
                        ctx.lineTo(startX, startY);
                    }

                    // Draw arc using arcTo
                    ctx.arcTo(curr[0], curr[1], endX, endY, r);
                }
            }

            ctx.closePath();
        }

        // ========== INITIALIZATION ==========
        function init() {
            canvas = document.getElementById('voronoiCanvas');
            ctx = canvas.getContext('2d');
            tooltip = document.getElementById('tooltip');

            resize();
            generateCells();
            setupEvents();
            initFpsCounter();
            animate(0);
        }

        function resize() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;

            width = rect.width;
            height = rect.height;

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            if (cells.length > 0) {
                generateCells();
            }
        }

        function generateCells() {
            cells = [];

            // Get zone bounds for cell placement
            const zone = getZoneBounds(false);
            const bounds = zone.cellBounds;

            // Ensure valid bounds
            const xMin = Math.max(40, bounds.xMin);
            const xMax = Math.min(width - 40, bounds.xMax);
            const yMin = Math.max(40, bounds.yMin);
            const yMax = Math.min(height - 40, bounds.yMax);

            const contentWidth = Math.max(100, xMax - xMin);
            const contentHeight = Math.max(100, yMax - yMin);
            const minDist = Math.sqrt((contentWidth * contentHeight) / config.cellCount) * 0.6;

            const points = [];
            let attempts = 0;

            // Generate cell positions within rotated zone
            while (points.length < config.cellCount && attempts < 2000) {
                const x = xMin + Math.random() * contentWidth;
                const y = yMin + Math.random() * contentHeight;

                // Check if point is inside the rotated zone
                let insideZone = true;
                for (const plane of zone.clipPlanes) {
                    const dist = (x - plane.px) * plane.nx + (y - plane.py) * plane.ny;
                    if (dist < -20) { // 20px margin from edge
                        insideZone = false;
                        break;
                    }
                }

                if (!insideZone) {
                    attempts++;
                    continue;
                }

                let valid = true;
                for (const p of points) {
                    const dx = p[0] - x, dy = p[1] - y;
                    if (dx * dx + dy * dy < minDist * minDist * 0.5) {
                        valid = false;
                        break;
                    }
                }

                if (valid) points.push([x, y]);
                attempts++;
            }

            // Fill remaining with random positions if needed
            while (points.length < config.cellCount) {
                const x = xMin + Math.random() * contentWidth;
                const y = yMin + Math.random() * contentHeight;
                points.push([x, y]);
            }

            // Create visible cells
            for (let i = 0; i < points.length; i++) {
                const cell = new Cell(points[i][0], points[i][1], i);
                cell.createPattern();
                cells.push(cell);
            }

            // Compute base Voronoi ONCE - shapes are fixed from here
            computeBaseVoronoi();
            updateDisplayPolygons();

            // Calculate parametric positions for each cell
            assignParametricPositions();
        }

        // Calculate parametric position (0-1) for each cell along the bar
        function assignParametricPositions() {
            if (cells.length === 0) return;

            const zone = getZoneBounds(false);
            const snappedAngle = zone.snappedAngle;
            const rotation = snappedAngle * Math.PI / 180;

            // Project each cell onto the bar's main axis
            const cos = Math.cos(rotation);
            const sin = Math.sin(rotation);

            // Get center for projection
            const cx = width / 2;
            const cy = height / 2;

            // Project cells onto the bar axis and find min/max
            const projections = cells.map(cell => {
                const dx = cell.baseX - cx;
                const dy = cell.baseY - cy;
                // Project onto bar direction (cos, sin)
                return dx * cos + dy * sin;
            });

            const minProj = Math.min(...projections);
            const maxProj = Math.max(...projections);
            const range = maxProj - minProj || 1;

            // Assign normalized parametric positions
            cells.forEach((cell, i) => {
                cell.parametricT = (projections[i] - minProj) / range;
            });
        }

        // Transition to a new preset with flock-like movement
        // Uses the separate FlockTransition system for clean animation
        function transitionToPreset(presetName) {
            if (config.currentPreset === presetName && !flockTransition.active) return;
            if (!presets[presetName]) return;
            if (flockTransition.active) return; // Don't interrupt ongoing transition

            const preset = presets[presetName];
            config.currentPreset = presetName;
            config.isTransitioning = true;

            // Update config to new preset values
            config.contentZoneRotation = preset.rotation;
            config.contentZonePosition = preset.position;
            config.contentZoneMargin = preset.margin;

            // Calculate target positions for each cell
            const rotation = preset.rotation * Math.PI / 180;
            const cos = Math.cos(rotation);
            const sin = Math.sin(rotation);

            // Calculate the center of the new zone
            const normalizedAngle = ((preset.rotation % 180) + 180) % 180;
            let offsetX = 0, offsetY = 0;

            if (normalizedAngle === 0) {
                offsetY = preset.position * (height / 2) * 0.8;
            } else if (normalizedAngle === 90) {
                offsetX = preset.position * (width / 2) * 0.8;
            } else {
                offsetX = preset.position * (width / 2) * 0.8;
            }

            const targetCenterX = width / 2 + offsetX;
            const targetCenterY = height / 2 + offsetY;
            const barLength = Math.sqrt(width * width + height * height) * 0.6;

            // Calculate target positions
            const goldenRatio = 0.618033988749;
            const targetPositions = cells.map((cell, index) => {
                const t = cell.parametricT;
                const barPos = (t - 0.5) * barLength;
                const spreadAmount = 50;
                const spreadPhase = ((index * goldenRatio) % 1) * 2 - 1;
                const perpOffset = spreadPhase * spreadAmount;

                return {
                    x: targetCenterX + barPos * cos - perpOffset * sin,
                    y: targetCenterY + barPos * sin + perpOffset * cos
                };
            });

            // Start the flock transition with callback for completion
            flockTransition.start(cells, targetPositions, (finalPositions) => {
                // Transition complete - update cells to final positions
                finalPositions.forEach(pos => {
                    const cell = cells.find(c => c.index === pos.index);
                    if (cell) {
                        cell.baseX = pos.x;
                        cell.baseY = pos.y;
                        cell.displacedX = pos.x;
                        cell.displacedY = pos.y;
                        cell.targetDisplacedX = pos.x;
                        cell.targetDisplacedY = pos.y;
                    }
                });

                // Resume normal physics
                config.isTransitioning = false;
                computeBaseVoronoi();
                assignParametricPositions();
            });

            // Update UI elements
            updatePresetUI(presetName);
            updateControlValues();
        }

        // Update control slider values to match current config
        function updateControlValues() {
            const rotationEl = document.getElementById('contentZoneRotation');
            const rotationVal = document.getElementById('contentZoneRotationVal');
            if (rotationEl) {
                rotationEl.value = config.contentZoneRotation;
                rotationVal.textContent = config.contentZoneRotation + '°';
            }

            const marginEl = document.getElementById('contentZoneMargin');
            const marginVal = document.getElementById('contentZoneMarginVal');
            if (marginEl) {
                marginEl.value = config.contentZoneMargin * 100;
                marginVal.textContent = Math.round(config.contentZoneMargin * 100) + '%';
            }

            const positionEl = document.getElementById('contentZonePosition');
            const positionVal = document.getElementById('contentZonePositionVal');
            if (positionEl) {
                positionEl.value = config.contentZonePosition * 100;
                positionVal.textContent = Math.round(config.contentZonePosition * 100) + '%';
            }
        }

        // Update preset radio button UI
        function updatePresetUI(activePreset) {
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.preset === activePreset);
            });
        }

        // ========== EVENTS ==========
        function setupEvents() {
            window.addEventListener('resize', () => {
                resize();
                // Recompute base Voronoi on resize
                computeBaseVoronoi();
                updateDisplayPolygons();
            });

            canvas.addEventListener('mousemove', handlePointerMove);
            canvas.addEventListener('mouseleave', handlePointerLeave);
            canvas.addEventListener('click', handleClick);

            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);

            setupControls();
        }

        function handlePointerMove(e) {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            updateHover();
            updateTooltip(e.clientX, e.clientY);
        }

        function handlePointerLeave() {
            mouseX = -9999;
            mouseY = -9999;
            hoveredCell = -1;
            cells.forEach(c => {
                c.targetZoom = config.nonHoverImageZoom;
                c.targetOpacity = config.nonHoveredOpacity;
            });
            tooltip.classList.remove('visible');
        }

        function handleClick() {
            if (hoveredCell >= 0 && cells[hoveredCell]) {
                const cell = cells[hoveredCell];
                if (cell.link) {
                    console.log('Navigate to:', cell.link);
                }
            }
        }

        let touchStartCell = -1;
        let touchStartTime = 0;

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            updateHover();
            touchStartCell = hoveredCell;
            touchStartTime = Date.now();
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            updateHover();
        }

        function handleTouchEnd() {
            if (Date.now() - touchStartTime < 300 && touchStartCell === hoveredCell && hoveredCell >= 0) {
                handleClick();
            }
            setTimeout(() => {
                mouseX = -9999;
                mouseY = -9999;
                hoveredCell = -1;
                cells.forEach(c => {
                    c.targetZoom = config.nonHoverImageZoom;
                    c.targetOpacity = config.nonHoveredOpacity;
                });
            }, 100);
        }

        function updateHover() {
            let found = -1;

            // Use polygon surface for hit detection
            for (let i = 0; i < cells.length; i++) {
                if (cells[i].polygon && pointInPolygon(mouseX, mouseY, cells[i].polygon)) {
                    found = i;
                    break;
                }
            }

            if (found !== hoveredCell) {
                if (hoveredCell >= 0) {
                    cells[hoveredCell].targetZoom = config.nonHoverImageZoom;
                    cells[hoveredCell].targetOpacity = config.nonHoveredOpacity;
                }
                hoveredCell = found;
                if (hoveredCell >= 0) {
                    cells[hoveredCell].targetZoom = 1.0;
                    cells[hoveredCell].targetOpacity = 1.0;
                }
            }

            canvas.style.cursor = hoveredCell >= 0 ? 'pointer' : 'default';
        }

        function pointInPolygon(x, y, polygon) {
            if (!polygon || polygon.length < 3) return false;

            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];

                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function updateTooltip(clientX, clientY) {
            if (hoveredCell >= 0 && cells[hoveredCell]) {
                const cell = cells[hoveredCell];
                tooltip.textContent = cell.title;
                tooltip.classList.add('visible');

                const rect = canvas.parentElement.getBoundingClientRect();
                const cursorX = clientX - rect.left;
                const cursorY = clientY - rect.top;

                // Direction from cell center to cursor
                const dx = cursorX - cell.x;
                const dy = cursorY - cell.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Position tooltip on opposite side of cursor from cell center
                // (in the "shadow" cast by cursor, away from the cell center "sun")
                const offset = 50;
                let tooltipX, tooltipY;

                if (dist > 1) {
                    // Normalize and extend in same direction (away from center)
                    tooltipX = cursorX + (dx / dist) * offset;
                    tooltipY = cursorY + (dy / dist) * offset;
                } else {
                    tooltipX = cursorX + offset;
                    tooltipY = cursorY;
                }

                // Get tooltip dimensions for boundary checking
                const tooltipRect = tooltip.getBoundingClientRect();
                const tw = tooltipRect.width || 100;
                const th = tooltipRect.height || 30;

                // Keep tooltip in bounds
                tooltipX = Math.max(5, Math.min(width - tw - 5, tooltipX));
                tooltipY = Math.max(5, Math.min(height - th - 5, tooltipY));

                tooltip.style.left = tooltipX + 'px';
                tooltip.style.top = tooltipY + 'px';
            } else {
                tooltip.classList.remove('visible');
            }
        }

        function setupControls() {
            // Cell count
            const cellCountEl = document.getElementById('cellCount');
            const cellCountVal = document.getElementById('cellCountVal');
            cellCountEl.addEventListener('input', () => {
                config.cellCount = +cellCountEl.value;
                cellCountVal.textContent = config.cellCount;
            });
            cellCountEl.addEventListener('change', generateCells);

            // Gap
            const gapEl = document.getElementById('gap');
            const gapVal = document.getElementById('gapVal');
            gapEl.addEventListener('input', () => {
                config.gap = +gapEl.value;
                gapVal.textContent = config.gap;
                // Gap is applied in updateDisplayPolygons() every frame
            });

            // Corner radius
            const cornerEl = document.getElementById('cornerRadius');
            const cornerVal = document.getElementById('cornerRadiusVal');
            cornerEl.addEventListener('input', () => {
                config.cornerRadius = +cornerEl.value;
                cornerVal.textContent = config.cornerRadius;
            });

            // Max Expansion (inflation)
            const maxExpansionEl = document.getElementById('maxExpansion');
            const maxExpansionVal = document.getElementById('maxExpansionVal');
            maxExpansionEl.addEventListener('input', () => {
                config.maxExpansion = +maxExpansionEl.value;
                maxExpansionVal.textContent = config.maxExpansion;
            });

            // In Speed - how fast cells expand on hover (1-100 scale)
            const expansionSpeedEl = document.getElementById('expansionSpeed');
            const expansionSpeedVal = document.getElementById('expansionSpeedVal');
            expansionSpeedEl.addEventListener('input', () => {
                config.expansionSpeed = +expansionSpeedEl.value;
                expansionSpeedVal.textContent = config.expansionSpeed;
            });

            // Out Speed - how fast cells shrink back after hover ends (1-100 scale)
            const retractionSpeedEl = document.getElementById('retractionSpeed');
            const retractionSpeedVal = document.getElementById('retractionSpeedVal');
            retractionSpeedEl.addEventListener('input', () => {
                config.retractionSpeed = +retractionSpeedEl.value;
                retractionSpeedVal.textContent = config.retractionSpeed;
            });

            // Displace Ratio - 0 = no neighbor push, 1 = max neighbor push
            const displaceRatioEl = document.getElementById('displaceRatio');
            const displaceRatioVal = document.getElementById('displaceRatioVal');
            displaceRatioEl.addEventListener('input', () => {
                config.displaceRatio = +displaceRatioEl.value / 100;
                displaceRatioVal.textContent = config.displaceRatio.toFixed(2);
            });

            // Displacement Falloff - how far displacement reaches (lower = local, higher = global)
            const displaceFalloffEl = document.getElementById('displaceFalloff');
            const displaceFalloffVal = document.getElementById('displaceFalloffVal');
            displaceFalloffEl.addEventListener('input', () => {
                config.displaceFalloff = +displaceFalloffEl.value;
                displaceFalloffVal.textContent = config.displaceFalloff;
            });

            // Non-Hovered Opacity
            const nonHoveredOpacityEl = document.getElementById('nonHoveredOpacity');
            const nonHoveredOpacityVal = document.getElementById('nonHoveredOpacityVal');
            nonHoveredOpacityEl.addEventListener('input', () => {
                config.nonHoveredOpacity = +nonHoveredOpacityEl.value / 100;
                nonHoveredOpacityVal.textContent = config.nonHoveredOpacity.toFixed(2);
                cells.forEach((c, i) => {
                    if (i !== hoveredCell) {
                        c.targetOpacity = config.nonHoveredOpacity;
                    }
                });
            });

            // Non-Hover Image Zoom
            const nonHoverImageZoomEl = document.getElementById('nonHoverImageZoom');
            const nonHoverImageZoomVal = document.getElementById('nonHoverImageZoomVal');
            nonHoverImageZoomEl.addEventListener('input', () => {
                config.nonHoverImageZoom = +nonHoverImageZoomEl.value / 10;
                nonHoverImageZoomVal.textContent = config.nonHoverImageZoom.toFixed(1);
                cells.forEach((c, i) => {
                    if (i !== hoveredCell) {
                        c.targetZoom = config.nonHoverImageZoom;
                    }
                });
            });

            // Image Zoom Speed
            const imageZoomSpeedEl = document.getElementById('imageZoomSpeed');
            const imageZoomSpeedVal = document.getElementById('imageZoomSpeedVal');
            imageZoomSpeedEl.addEventListener('input', () => {
                config.imageZoomSpeed = +imageZoomSpeedEl.value;
                imageZoomSpeedVal.textContent = config.imageZoomSpeed;
            });

            // Content Zone Controls
            // Zone Margin
            const contentZoneMarginEl = document.getElementById('contentZoneMargin');
            const contentZoneMarginVal = document.getElementById('contentZoneMarginVal');
            contentZoneMarginEl.addEventListener('input', () => {
                config.contentZoneMargin = +contentZoneMarginEl.value / 100;
                contentZoneMarginVal.textContent = contentZoneMarginEl.value + '%';
            });
            contentZoneMarginEl.addEventListener('change', generateCells);

            // Zone Rotation
            const contentZoneRotationEl = document.getElementById('contentZoneRotation');
            const contentZoneRotationVal = document.getElementById('contentZoneRotationVal');
            contentZoneRotationEl.addEventListener('input', () => {
                config.contentZoneRotation = +contentZoneRotationEl.value;
                contentZoneRotationVal.textContent = config.contentZoneRotation + '°';
            });
            contentZoneRotationEl.addEventListener('change', generateCells);

            // Zone Position
            const contentZonePositionEl = document.getElementById('contentZonePosition');
            const contentZonePositionVal = document.getElementById('contentZonePositionVal');
            contentZonePositionEl.addEventListener('input', () => {
                config.contentZonePosition = +contentZonePositionEl.value / 100;
                contentZonePositionVal.textContent = contentZonePositionEl.value + '%';
            });
            contentZonePositionEl.addEventListener('change', generateCells);

            // Transition Speed
            const transitionSpeedEl = document.getElementById('transitionSpeed');
            const transitionSpeedVal = document.getElementById('transitionSpeedVal');
            transitionSpeedEl.addEventListener('input', () => {
                config.transitionSpeed = +transitionSpeedEl.value;
                transitionSpeedVal.textContent = config.transitionSpeed;
            });

            // Preset buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.preset;
                    if (preset) {
                        transitionToPreset(preset);
                    }
                });
            });

            const bleedBufferEl = document.getElementById('bleedBuffer');
            const bleedBufferVal = document.getElementById('bleedBufferVal');
            bleedBufferEl.addEventListener('input', () => {
                config.bleedBuffer = +bleedBufferEl.value;
                bleedBufferVal.textContent = config.bleedBuffer;
                // Buffer affects base Voronoi bounds - need to recompute
                computeBaseVoronoi();
            });

            // Buttons
            document.getElementById('regenerate').addEventListener('click', generateCells);

            const toggleContentZone = document.getElementById('toggleContentZone');
            toggleContentZone.classList.toggle('active', config.contentZoneEnabled);
            toggleContentZone.addEventListener('click', () => {
                config.contentZoneEnabled = !config.contentZoneEnabled;
                toggleContentZone.classList.toggle('active', config.contentZoneEnabled);
                generateCells();
            });

            const toggleDebug = document.getElementById('toggleDebug');
            toggleDebug.addEventListener('click', () => {
                config.debugMode = !config.debugMode;
                toggleDebug.classList.toggle('active', config.debugMode);
            });

            const loadUnsplash = document.getElementById('loadUnsplash');
            loadUnsplash.addEventListener('click', loadUnsplashImages);
        }

        // ========== UNSPLASH IMAGES ==========
        function loadUnsplashImages() {
            const btn = document.getElementById('loadUnsplash');
            btn.textContent = 'Loading...';
            btn.disabled = true;

            let loaded = 0;
            const total = cells.length;

            cells.forEach((cell, i) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                // Use random seed for variety, sig for cache busting
                img.src = `https://picsum.photos/300/300?random=${i}&t=${Date.now()}`;

                img.onload = () => {
                    const size = 300;
                    const patternCanvas = document.createElement('canvas');
                    patternCanvas.width = size;
                    patternCanvas.height = size;
                    const pctx = patternCanvas.getContext('2d');

                    // Draw image covering the canvas
                    pctx.drawImage(img, 0, 0, size, size);

                    cell.pattern = patternCanvas;
                    loaded++;

                    if (loaded >= total) {
                        btn.textContent = 'Unsplash';
                        btn.disabled = false;
                    }
                };

                img.onerror = () => {
                    loaded++;
                    if (loaded >= total) {
                        btn.textContent = 'Unsplash';
                        btn.disabled = false;
                    }
                };
            });
        }

        // ========== PHYSICS ==========
        // Normal physics for hover/displacement effects
        // Note: Bar transitions are handled separately by FlockTransition system
        function updatePhysics(dt) {
            // Scale factor: 1.0 = normal, 1.0 + maxExpansion/300 = expanded
            const expandedScale = 1.0 + config.maxExpansion / 300;

            // Set target scales first
            for (let i = 0; i < cells.length; i++) {
                cells[i].targetScale = (i === hoveredCell) ? expandedScale : 1.0;
            }

            // Compute and constrain displacement targets
            computeDisplacementTargets();

            // Run cell animations
            for (let i = 0; i < cells.length; i++) {
                cells[i].update(dt, i === hoveredCell);
            }

            // Update display polygons
            updateDisplayPolygons();
        }

        // ========== RENDERING ==========
        function render() {
            ctx.clearRect(0, 0, width, height);

            // Helper to draw a single cell
            function drawCell(i) {
                const cell = cells[i];
                const polygon = cell.displayPolygon;

                if (!polygon || polygon.length < 3) return;

                ctx.save();

                // Apply opacity
                ctx.globalAlpha = cell.opacity;

                // Create rounded clipping path
                drawRoundedPolygon(ctx, polygon, config.cornerRadius);
                ctx.clip();

                // Calculate bounds
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const p of polygon) {
                    minX = Math.min(minX, p[0]);
                    maxX = Math.max(maxX, p[0]);
                    minY = Math.min(minY, p[1]);
                    maxY = Math.max(maxY, p[1]);
                }

                const cellW = maxX - minX;
                const cellH = maxY - minY;
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                // Draw pattern with zoom
                if (cell.pattern) {
                    const zoom = cell.zoom;
                    const size = Math.max(cellW, cellH) * 1.4 * zoom;
                    ctx.drawImage(
                        cell.pattern,
                        centerX - size / 2,
                        centerY - size / 2,
                        size,
                        size
                    );
                }

                ctx.restore();

                // Draw border (inner stroke to avoid optical distortion)
                ctx.save();
                const hoverGlow = cell.hoverMix;
                const isHovered = i === hoveredCell;

                // For hovered cell, use full opacity; for others, use cell opacity
                const strokeAlpha = isHovered ? 1.0 : Math.max(0.35, cell.opacity) * 0.5;
                const baseLineWidth = isHovered ? 2 : 1;
                const lineWidth = baseLineWidth + hoverGlow * 2;

                // Create clip path for inner stroke
                drawRoundedPolygon(ctx, polygon, config.cornerRadius);
                ctx.clip();

                // Draw stroke with doubled width (half will be clipped outside)
                drawRoundedPolygon(ctx, polygon, config.cornerRadius);
                ctx.strokeStyle = `rgba(255,255,255,${strokeAlpha})`;
                ctx.lineWidth = lineWidth * 2; // Double width since half is clipped

                // Only apply glow for hovered cells
                if (isHovered) {
                    ctx.shadowColor = `rgba(255,255,255,${0.5 * hoverGlow})`;
                    ctx.shadowBlur = 12 * hoverGlow;
                }

                ctx.stroke();
                ctx.restore();
            }

            // Draw non-hovered cells first
            for (let i = 0; i < cells.length; i++) {
                if (i !== hoveredCell) {
                    drawCell(i);
                }
            }

            // Draw hovered cell LAST (on top) so it can overlap neighbors
            if (hoveredCell >= 0 && hoveredCell < cells.length) {
                drawCell(hoveredCell);
            }

            // No mask - cells themselves define the boundary
            // Non-hovered cells are clipped to soft bounds
            // Hovered cell extends into buffer - what you see is what you get

            // Debug mode
            if (config.debugMode) {
                if (config.contentZoneEnabled) {
                    const zone = getZoneBounds(false);
                    const zoneWithBuffer = getZoneBounds(true);

                    // Draw buffer zone (outer boundary)
                    ctx.strokeStyle = 'rgba(255, 150, 50, 1)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(zoneWithBuffer.bounds[0][0], zoneWithBuffer.bounds[0][1]);
                    for (let i = 1; i < zoneWithBuffer.bounds.length; i++) {
                        ctx.lineTo(zoneWithBuffer.bounds[i][0], zoneWithBuffer.bounds[i][1]);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    // Draw content zone (inner boundary)
                    ctx.strokeStyle = 'rgba(100, 255, 100, 1)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 4]);
                    ctx.beginPath();
                    ctx.moveTo(zone.bounds[0][0], zone.bounds[0][1]);
                    for (let i = 1; i < zone.bounds.length; i++) {
                        ctx.lineTo(zone.bounds[i][0], zone.bounds[i][1]);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Label
                    ctx.font = '12px monospace';
                    ctx.fillStyle = 'rgba(255, 150, 50, 1)';
                    ctx.fillText('BUFFER EDGE (orange)', 10, 20);
                    ctx.fillStyle = 'rgba(100, 255, 100, 1)';
                    ctx.fillText('CONTENT ZONE (green) - Angle: ' + zone.snappedAngle + '° (snapped from ' + config.contentZoneRotation + '°)', 10, 40);
                }

                // Draw cell debug info
                for (const cell of cells) {
                    const polygon = cell.displayPolygon;
                    const centroid = cell.baseCentroid || { x: cell.baseX, y: cell.baseY };

                    // Draw seed displacement (line from base to displaced position)
                    if (cell.displacedX !== undefined) {
                        const dx = cell.displacedX - cell.baseX;
                        const dy = cell.displacedY - cell.baseY;
                        const displacement = Math.sqrt(dx * dx + dy * dy);

                        if (displacement > 1) {
                            // Draw line showing displacement
                            ctx.strokeStyle = 'rgba(255, 100, 100, 0.9)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(cell.baseX, cell.baseY);
                            ctx.lineTo(cell.displacedX, cell.displacedY);
                            ctx.stroke();

                            // Draw displaced position (red dot)
                            ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                            ctx.beginPath();
                            ctx.arc(cell.displacedX, cell.displacedY, 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Draw lines from each corner to cell center
                    if (polygon && polygon.length >= 3) {
                        ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([3, 3]);
                        for (const corner of polygon) {
                            ctx.beginPath();
                            ctx.moveTo(corner[0], corner[1]);
                            ctx.lineTo(centroid.x, centroid.y);
                            ctx.stroke();
                        }
                        ctx.setLineDash([]);

                        // Draw corner dots
                        ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
                        for (const corner of polygon) {
                            ctx.beginPath();
                            ctx.arc(corner[0], corner[1], 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Base seed position (white dot)
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(cell.baseX, cell.baseY, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Centroid (shows where polygon center actually is)
                    const dotSize = 4 + (cell.scale - 1) * 20;
                    ctx.fillStyle = cell.scale > 1.01 ? 'rgba(255,200,100,0.9)' : 'rgba(100,200,255,0.7)';
                    ctx.beginPath();
                    ctx.arc(centroid.x, centroid.y, dotSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // ========== ANIMATION LOOP ==========
        function animate(time) {
            const deltaMs = time - lastTime;
            const dt = Math.min(deltaMs / 16, 3);
            lastTime = time;

            // Check if flock transition is active
            if (flockTransition.active) {
                // Run the flock transition system (completely separate from normal physics)
                flockTransition.update(dt);
                flockTransition.render(ctx, config.cornerRadius);
            } else {
                // Normal physics and rendering
                updatePhysics(dt);
                render();
            }

            // Update FPS counter (skip first frame where deltaMs would be huge)
            if (deltaMs > 0 && deltaMs < 200) {
                updateFpsCounter(deltaMs);
            }

            animationId = requestAnimationFrame(animate);
        }

        // ========== START ==========
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    })();
    </script>
</body>
</html>
