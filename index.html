<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Interactive Voronoi Grid</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #voronoiCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            pointer-events: none;
            opacity: 0;
            transform: translateY(5px);
            transition: opacity 0.2s, transform 0.2s;
            z-index: 100;
            white-space: nowrap;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .controls {
            background: rgba(20, 20, 35, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255,255,255,0.1);
            padding: 12px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px 16px;
            align-items: flex-end;
        }

        .control-section {
            display: contents;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 100px;
        }

        .control-group.wide {
            min-width: 130px;
        }

        .control-group label {
            font-size: 9px;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        input[type="range"] {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.15);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(99,102,241,0.4);
            transition: transform 0.15s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .control-value {
            font-size: 11px;
            color: #fff;
            font-weight: 600;
            min-width: 28px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        .btn {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: #fff;
            box-shadow: 0 4px 15px rgba(99,102,241,0.3);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(99,102,241,0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.15);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.15);
        }

        .btn-secondary.active {
            background: rgba(99,102,241,0.3);
            border-color: rgba(99,102,241,0.5);
        }

        .divider {
            width: 1px;
            height: 36px;
            background: rgba(255,255,255,0.1);
        }

        @media (max-width: 1100px) {
            .control-group.hide-tablet {
                display: none;
            }
        }

        @media (max-width: 800px) {
            .controls {
                padding: 10px 12px;
                gap: 10px 12px;
            }
            .control-group.hide-mobile {
                display: none;
            }
            .btn-group {
                width: 100%;
                margin-left: 0;
                justify-content: flex-end;
            }
            .divider {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="canvas-container">
            <canvas id="voronoiCanvas"></canvas>
            <div class="tooltip" id="tooltip"></div>
        </div>
        <div class="controls">
            <!-- Grid Settings -->
            <div class="control-group">
                <label>Cells</label>
                <div class="control-row">
                    <input type="range" id="cellCount" min="4" max="30" value="12">
                    <span class="control-value" id="cellCountVal">12</span>
                </div>
            </div>
            <div class="control-group">
                <label>Gap</label>
                <div class="control-row">
                    <input type="range" id="gap" min="0" max="30" value="27">
                    <span class="control-value" id="gapVal">27</span>
                </div>
            </div>
            <div class="control-group">
                <label>Corners</label>
                <div class="control-row">
                    <input type="range" id="cornerRadius" min="0" max="40" value="23">
                    <span class="control-value" id="cornerRadiusVal">23</span>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Hover Effect -->
            <div class="control-group">
                <label>Hover Size</label>
                <div class="control-row">
                    <input type="range" id="maxExpansion" min="0" max="400" value="400">
                    <span class="control-value" id="maxExpansionVal">400</span>
                </div>
            </div>
            <div class="control-group">
                <label>In Speed</label>
                <div class="control-row">
                    <input type="range" id="expansionSpeed" min="0" max="100" value="8">
                    <span class="control-value" id="expansionSpeedVal">8</span>
                </div>
            </div>
            <div class="control-group">
                <label>Out Speed</label>
                <div class="control-row">
                    <input type="range" id="retractionSpeed" min="0" max="100" value="2">
                    <span class="control-value" id="retractionSpeedVal">2</span>
                </div>
            </div>
            <div class="control-group">
                <label>Displace</label>
                <div class="control-row">
                    <input type="range" id="displaceRatio" min="0" max="100" value="100">
                    <span class="control-value" id="displaceRatioVal">1.00</span>
                </div>
            </div>
            <div class="control-group">
                <label>Falloff</label>
                <div class="control-row">
                    <input type="range" id="displaceFalloff" min="100" max="800" value="300">
                    <span class="control-value" id="displaceFalloffVal">300</span>
                </div>
            </div>
            <div class="control-group">
                <label>Dim Others</label>
                <div class="control-row">
                    <input type="range" id="nonHoveredOpacity" min="0" max="100" value="36">
                    <span class="control-value" id="nonHoveredOpacityVal">0.36</span>
                </div>
            </div>
            <div class="control-group hide-mobile">
                <label>Image Zoom</label>
                <div class="control-row">
                    <input type="range" id="nonHoverImageZoom" min="10" max="80" value="30" step="1">
                    <span class="control-value" id="nonHoverImageZoomVal">3.0</span>
                </div>
            </div>
            <div class="control-group hide-mobile">
                <label>Zoom Speed</label>
                <div class="control-row">
                    <input type="range" id="imageZoomSpeed" min="1" max="100" value="3">
                    <span class="control-value" id="imageZoomSpeedVal">3</span>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Content Zone -->
            <div class="control-group">
                <label>Zone Margin</label>
                <div class="control-row">
                    <input type="range" id="contentZoneMargin" min="0" max="40" value="15">
                    <span class="control-value" id="contentZoneMarginVal">15%</span>
                </div>
            </div>
            <div class="control-group">
                <label>Zone Angle</label>
                <div class="control-row">
                    <input type="range" id="contentZoneRotation" min="0" max="315" value="0" step="45">
                    <span class="control-value" id="contentZoneRotationVal">0°</span>
                </div>
            </div>
            <div class="control-group hide-tablet">
                <label>Bleed Buffer</label>
                <div class="control-row">
                    <input type="range" id="bleedBuffer" min="20" max="200" value="158">
                    <span class="control-value" id="bleedBufferVal">158</span>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Buttons -->
            <div class="btn-group">
                <button class="btn btn-secondary" id="toggleContentZone">Zone</button>
                <button class="btn btn-secondary" id="toggleDebug">Debug</button>
                <button class="btn btn-secondary" id="loadUnsplash">Unsplash</button>
                <button class="btn btn-primary" id="regenerate">Regenerate</button>
            </div>
        </div>
    </div>

    <script>
    (function() {
        'use strict';

        // ========== CONFIGURATION ==========
        const config = {
            // Grid settings
            cellCount: 12,
            gap: 27,
            cornerRadius: 23,

            // Inflation system
            maxExpansion: 400,           // How much the hovered cell inflates (affects neighbor push)
            expansionSpeed: 8,           // How fast cells inflate (1-100 scale, higher = faster)
            retractionSpeed: 2,          // How fast cells retract after hover ends (1-100 scale)
            displaceRatio: 1.0,          // 0 = no neighbor push, 1 = max neighbor push
            displaceFalloff: 300,        // How far displacement reaches (px) - lower = more local, higher = affects distant cells

            // Visual transitions
            nonHoverImageZoom: 3.0,      // Non-hover image zoom level
            imageZoomSpeed: 3,           // How fast image zoom transitions (1-100 scale)
            nonHoveredOpacity: 0.36,     // Opacity for non-hovered cells
            opacityTransitionSpeed: 0.15, // How fast opacity transitions

            // Toggles
            physicsEnabled: true,
            debugMode: false,

            // Content zone / soft boundary
            contentZoneEnabled: true,    // Enable/disable content zone
            contentZoneMargin: 0.15,     // Margin as fraction of zone dimension
            contentZoneRotation: 0,      // Rotation in degrees (0 = horizontal, 90 = vertical)
            bleedBuffer: 158             // Pixel buffer beyond content zone (how far hovered cell can extend)
        };

        // ========== SAMPLE DATA ==========
        const cellData = [
            { title: 'Cosmic Dreams', link: '#cosmic', color: '#6366f1' },
            { title: 'Ocean Depths', link: '#ocean', color: '#06b6d4' },
            { title: 'Forest Whispers', link: '#forest', color: '#10b981' },
            { title: 'Solar Flare', link: '#solar', color: '#f59e0b' },
            { title: 'Cherry Blossom', link: '#cherry', color: '#ec4899' },
            { title: 'Arctic Aurora', link: '#arctic', color: '#8b5cf6' },
            { title: 'Desert Gold', link: '#desert', color: '#eab308' },
            { title: 'Midnight Jazz', link: '#jazz', color: '#3b82f6' },
            { title: 'Ember Glow', link: '#ember', color: '#ef4444' },
            { title: 'Mint Fresh', link: '#mint', color: '#14b8a6' },
            { title: 'Lavender Fields', link: '#lavender', color: '#a855f7' },
            { title: 'Coral Reef', link: '#coral', color: '#f97316' },
            { title: 'Storm Cloud', link: '#storm', color: '#64748b' },
            { title: 'Neon Nights', link: '#neon', color: '#d946ef' },
            { title: 'Sage Garden', link: '#sage', color: '#84cc16' },
            { title: 'Ruby Dreams', link: '#ruby', color: '#dc2626' },
            { title: 'Sapphire Sky', link: '#sapphire', color: '#2563eb' },
            { title: 'Amber Waves', link: '#amber', color: '#d97706' },
            { title: 'Violet Hour', link: '#violet', color: '#7c3aed' },
            { title: 'Teal Depths', link: '#teal', color: '#0d9488' },
            { title: 'Rose Petals', link: '#rose', color: '#e11d48' },
            { title: 'Lime Zest', link: '#lime', color: '#65a30d' },
            { title: 'Indigo Night', link: '#indigo', color: '#4f46e5' },
            { title: 'Peach Sunset', link: '#peach', color: '#fb923c' },
            { title: 'Cyan Wave', link: '#cyan', color: '#22d3d8' },
            { title: 'Magenta Pulse', link: '#magenta', color: '#c026d3' },
            { title: 'Bronze Age', link: '#bronze', color: '#a16207' },
            { title: 'Steel Blue', link: '#steel', color: '#475569' },
            { title: 'Crimson Tide', link: '#crimson', color: '#be123c' },
            { title: 'Emerald City', link: '#emerald', color: '#059669' }
        ];

        // ========== STATE ==========
        let canvas, ctx;
        let width, height;
        let cells = [];
        let hoveredCell = -1;
        let mouseX = -9999, mouseY = -9999;
        let tooltip;
        let animationId;
        let lastTime = 0;

        // ========== EASING UTILITIES ==========
        // Attempt to compute the t value for a given x on cubic bezier curve
        // Returns x directly since we use symmetric ease curves
        function cubicBezierEase(t, p1, p2) {
            // Attempt to compute cubic bezier with control points (0,0), (p1,p1), (p2,p2), (1,1)
            // For ease-in-out this gives smooth acceleration and deceleration
            // Using approximate formula for common easing curves
            const t2 = t * t;
            const t3 = t2 * t;
            const mt = 1 - t;
            const mt2 = mt * mt;
            const mt3 = mt2 * mt;

            // Cubic bezier: B(t) = (1-t)³P0 + 3(1-t)²tP1 + 3(1-t)t²P2 + t³P3
            // With P0=0, P1=p1, P2=p2, P3=1
            return 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3;
        }

        // Ease-out: starts fast, slows down at end (good for arriving at target)
        function easeOut(t) {
            return cubicBezierEase(t, 0.0, 0.58);
        }

        // Ease-in-out: slow start, fast middle, slow end (good for smooth transitions)
        function easeInOut(t) {
            return cubicBezierEase(t, 0.42, 0.58);
        }

        // Smooth ease-out with slight overshoot feel (Material Design style)
        function easeOutSmooth(t) {
            // Deceleration curve - fast start, gentle landing
            return 1 - Math.pow(1 - t, 3);
        }

        // ========== CELL CLASS ==========
        class Cell {
            constructor(x, y, index) {
                this.index = index;
                this.baseX = x;
                this.baseY = y;
                this.x = x;
                this.y = y;

                // Scale animation (progress-based with bezier easing)
                this.scale = 1.0;              // Current scale
                this.targetScale = 1.0;        // Target scale
                this.scaleStart = 1.0;         // Start value for current animation
                this.scaleProgress = 1.0;      // Animation progress 0-1 (1 = complete)
                this.lastTargetScale = 1.0;    // To detect target changes

                // Displacement animation (progress-based)
                this.displacedX = x;           // Current displaced position
                this.displacedY = y;
                this.targetDisplacedX = x;     // Target displaced position
                this.targetDisplacedY = y;
                this.displaceStartX = x;       // Start position for current animation
                this.displaceStartY = y;
                this.displaceProgress = 1.0;   // Animation progress 0-1
                this.lastTargetDisplacedX = x; // To detect target changes
                this.lastTargetDisplacedY = y;

                this.basePolygon = null;   // Computed once at init - NEVER changes
                this.baseCentroid = null;  // Center of base polygon
                this.polygon = null;       // For hit testing
                this.displayPolygon = null; // What gets rendered

                // Zoom animation (progress-based)
                this.zoom = config.nonHoverImageZoom;
                this.targetZoom = config.nonHoverImageZoom;
                this.zoomStart = config.nonHoverImageZoom;
                this.zoomProgress = 1.0;
                this.lastTargetZoom = config.nonHoverImageZoom;

                // Opacity animation (progress-based)
                this.opacity = config.nonHoveredOpacity;
                this.targetOpacity = config.nonHoveredOpacity;
                this.opacityStart = config.nonHoveredOpacity;
                this.opacityProgress = 1.0;
                this.lastTargetOpacity = config.nonHoveredOpacity;

                const data = cellData[index % cellData.length];
                this.title = data.title;
                this.link = data.link;
                this.color = data.color;
                this.pattern = null;
            }

            update(dt, isHovered) {
                // Progress-based animation with bezier easing
                // Speed 1-100 maps to animation duration: higher speed = shorter duration
                // At speed 1, animation takes ~2 seconds; at speed 100, nearly instant

                // === SCALE ANIMATION ===
                // Detect target change - start new animation from current position
                if (this.targetScale !== this.lastTargetScale) {
                    this.scaleStart = this.scale;
                    this.scaleProgress = 0;
                    this.lastTargetScale = this.targetScale;
                }

                if (this.scaleProgress < 1) {
                    // Determine animation speed based on direction
                    const expanding = this.targetScale > this.scaleStart;
                    const rawSpeed = expanding ? config.expansionSpeed : config.retractionSpeed;
                    // Convert 1-100 to progress rate: speed 1 = 0.5/sec, speed 100 = 50/sec
                    const progressRate = rawSpeed * 0.5;
                    this.scaleProgress = Math.min(1, this.scaleProgress + progressRate * dt / 1000);

                    // Apply bezier easing to progress
                    const easedProgress = easeOutSmooth(this.scaleProgress);

                    // Interpolate between start and target
                    this.scale = this.scaleStart + (this.targetScale - this.scaleStart) * easedProgress;
                } else {
                    this.scale = this.targetScale;
                }

                // === DISPLACEMENT ANIMATION ===
                // Detect target change
                const targetDisplaceChanged =
                    Math.abs(this.targetDisplacedX - this.lastTargetDisplacedX) > 0.5 ||
                    Math.abs(this.targetDisplacedY - this.lastTargetDisplacedY) > 0.5;

                if (targetDisplaceChanged) {
                    this.displaceStartX = this.displacedX;
                    this.displaceStartY = this.displacedY;
                    this.displaceProgress = 0;
                    this.lastTargetDisplacedX = this.targetDisplacedX;
                    this.lastTargetDisplacedY = this.targetDisplacedY;
                }

                if (this.displaceProgress < 1) {
                    // Determine if returning to base (use Out Speed) or being pushed (use In Speed)
                    const targetDistFromBase = Math.sqrt(
                        Math.pow(this.targetDisplacedX - this.baseX, 2) +
                        Math.pow(this.targetDisplacedY - this.baseY, 2)
                    );
                    const startDistFromBase = Math.sqrt(
                        Math.pow(this.displaceStartX - this.baseX, 2) +
                        Math.pow(this.displaceStartY - this.baseY, 2)
                    );
                    const isReturning = targetDistFromBase < startDistFromBase;
                    const rawSpeed = isReturning ? config.retractionSpeed : config.expansionSpeed;
                    const progressRate = rawSpeed * 0.5;
                    this.displaceProgress = Math.min(1, this.displaceProgress + progressRate * dt / 1000);

                    const easedProgress = easeOutSmooth(this.displaceProgress);

                    this.displacedX = this.displaceStartX + (this.targetDisplacedX - this.displaceStartX) * easedProgress;
                    this.displacedY = this.displaceStartY + (this.targetDisplacedY - this.displaceStartY) * easedProgress;
                } else {
                    this.displacedX = this.targetDisplacedX;
                    this.displacedY = this.targetDisplacedY;
                }

                // === ZOOM ANIMATION ===
                if (this.targetZoom !== this.lastTargetZoom) {
                    this.zoomStart = this.zoom;
                    this.zoomProgress = 0;
                    this.lastTargetZoom = this.targetZoom;
                }

                if (this.zoomProgress < 1) {
                    const progressRate = config.imageZoomSpeed * 0.5;
                    this.zoomProgress = Math.min(1, this.zoomProgress + progressRate * dt / 1000);
                    const easedProgress = easeOutSmooth(this.zoomProgress);
                    this.zoom = this.zoomStart + (this.targetZoom - this.zoomStart) * easedProgress;
                } else {
                    this.zoom = this.targetZoom;
                }

                // === OPACITY ANIMATION ===
                if (this.targetOpacity !== this.lastTargetOpacity) {
                    this.opacityStart = this.opacity;
                    this.opacityProgress = 0;
                    this.lastTargetOpacity = this.targetOpacity;
                }

                if (this.opacityProgress < 1) {
                    // Opacity uses a fixed moderate speed
                    const progressRate = 8 * 0.5; // Equivalent to speed ~8
                    this.opacityProgress = Math.min(1, this.opacityProgress + progressRate * dt / 1000);
                    const easedProgress = easeOutSmooth(this.opacityProgress);
                    this.opacity = this.opacityStart + (this.targetOpacity - this.opacityStart) * easedProgress;
                } else {
                    this.opacity = this.targetOpacity;
                }
            }

            createPattern() {
                const size = 300;
                const patternCanvas = document.createElement('canvas');
                patternCanvas.width = size;
                patternCanvas.height = size;
                const pctx = patternCanvas.getContext('2d');

                // Gradient background
                const gradient = pctx.createLinearGradient(0, 0, size, size);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(1, this.adjustColor(this.color, -40));
                pctx.fillStyle = gradient;
                pctx.fillRect(0, 0, size, size);

                // Decorative circles
                pctx.globalAlpha = 0.08;
                for (let i = 0; i < 5; i++) {
                    const cx = Math.random() * size;
                    const cy = Math.random() * size;
                    const r = 30 + Math.random() * 60;
                    pctx.beginPath();
                    pctx.arc(cx, cy, r, 0, Math.PI * 2);
                    pctx.fillStyle = '#fff';
                    pctx.fill();
                }

                // Cell number
                pctx.globalAlpha = 0.2;
                pctx.fillStyle = '#fff';
                pctx.font = `bold ${size * 0.35}px system-ui, sans-serif`;
                pctx.textAlign = 'center';
                pctx.textBaseline = 'middle';
                pctx.fillText(this.index + 1, size / 2, size / 2);

                this.pattern = patternCanvas;
            }

            adjustColor(hex, amount) {
                const num = parseInt(hex.slice(1), 16);
                const r = Math.min(255, Math.max(0, (num >> 16) + amount));
                const g = Math.min(255, Math.max(0, ((num >> 8) & 0xff) + amount));
                const b = Math.min(255, Math.max(0, (num & 0xff) + amount));
                return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
            }
        }

        // ========== TRUE EDGE-BASED VORONOI ==========
        // Edges are LINES between cells (not clipped surfaces)
        // Vertices are computed as intersections of edges
        // This ensures consistent topology and shared boundaries

        let voronoiEdges = [];      // Edges between cell pairs
        let cellEdgeMap = [];       // For each cell, list of edge indices + neighbor info

        // Helper to compute rotated zone bounds
        // The zone is a "band" that can rotate in 45° increments
        // Uses 8 discrete rulesets for reliable clipping at each angle
        // Returns { bounds: [[x,y],...], clipPlanes: [{px,py,nx,ny},...], cellBounds: {xMin,xMax,yMin,yMax} }
        function getZoneBounds(includeBuffer = false) {
            const margin = config.contentZoneEnabled ? config.contentZoneMargin : 0;
            const buffer = includeBuffer ? config.bleedBuffer : 0;

            const cx = width / 2;
            const cy = height / 2;

            // Snap to nearest 45° for discrete rulesets
            const rawAngle = config.contentZoneRotation;
            const snappedAngle = Math.round(rawAngle / 45) * 45 % 360;
            const rotation = snappedAngle * Math.PI / 180;

            const cos = Math.cos(rotation);
            const sin = Math.sin(rotation);

            // Band length: screen diagonal ensures full coverage at any angle
            const diagonal = Math.sqrt(width * width + height * height);
            const halfLength = diagonal / 2 + buffer;

            // Band thickness depends on angle sector
            // 0°/180°: use height, 90°/270°: use width, 45°/135°/225°/315°: use diagonal blend
            let effectiveSize;
            const normalizedAngle = ((snappedAngle % 180) + 180) % 180; // 0-179

            if (normalizedAngle === 0) {
                // Horizontal band
                effectiveSize = height;
            } else if (normalizedAngle === 90) {
                // Vertical band
                effectiveSize = width;
            } else {
                // Diagonal bands (45°, 135°)
                // For diagonals, use the smaller dimension to maintain reasonable thickness
                effectiveSize = Math.min(width, height) * 1.2;
            }

            const halfThickness = (effectiveSize / 2) * (1 - margin) + buffer;

            // Create band rectangle in local coords (length along X, thickness along Y)
            const localCorners = [
                [-halfLength, -halfThickness],
                [halfLength, -halfThickness],
                [halfLength, halfThickness],
                [-halfLength, halfThickness]
            ];

            // Rotate and translate to screen center
            const corners = localCorners.map(([lx, ly]) => [
                cx + lx * cos - ly * sin,
                cy + lx * sin + ly * cos
            ]);

            // Build clip planes with correct inward normals for each edge
            // Edge order: top, right, bottom, left (in rotated space)
            // Normals must point INTO the rectangle
            const clipPlanes = [];

            // For each edge, compute the inward-pointing normal
            // The rectangle winds CW in screen coords, so inward is to the LEFT of edge direction
            for (let i = 0; i < 4; i++) {
                const p1 = corners[i];
                const p2 = corners[(i + 1) % 4];
                const ex = p2[0] - p1[0];
                const ey = p2[1] - p1[1];
                const len = Math.sqrt(ex * ex + ey * ey);
                if (len < 0.001) continue;

                // For CW winding, inward normal is (ey, -ex) / len
                // For CCW winding, inward normal is (-ey, ex) / len
                // Our corners are defined CCW in local space, but screen Y is inverted...
                // Let's verify by checking if center is on positive side
                const midX = (p1[0] + p2[0]) / 2;
                const midY = (p1[1] + p2[1]) / 2;

                // Try one normal direction
                let nx = -ey / len;
                let ny = ex / len;

                // Check if center is on positive side (inside)
                const centerDist = (cx - midX) * nx + (cy - midY) * ny;
                if (centerDist < 0) {
                    // Wrong direction, flip it
                    nx = -nx;
                    ny = -ny;
                }

                clipPlanes.push({ px: midX, py: midY, nx, ny });
            }

            // Cell generation bounds - shrink from zone for seed placement
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const [x, y] of corners) {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }

            const cellBounds = {
                xMin: Math.max(40, minX + 60),
                xMax: Math.min(width - 40, maxX - 60),
                yMin: Math.max(40, minY + 60),
                yMax: Math.min(height - 40, maxY - 60)
            };

            return { bounds: corners, clipPlanes, cellBounds, snappedAngle };
        }

        function computeBaseVoronoi() {
            const zone = getZoneBounds(true);
            const buffer = config.bleedBuffer;

            // Build edges between all cell pairs
            voronoiEdges = [];
            cellEdgeMap = cells.map(() => []);

            for (let i = 0; i < cells.length; i++) {
                for (let j = i + 1; j < cells.length; j++) {
                    const cellA = cells[i];
                    const cellB = cells[j];

                    const dx = cellB.baseX - cellA.baseX;
                    const dy = cellB.baseY - cellA.baseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 0.001) continue;

                    const edgeIdx = voronoiEdges.length;

                    // Edge as a LINE: point on line (midpoint) + direction (perpendicular to cell-cell line)
                    const midX = (cellA.baseX + cellB.baseX) / 2;
                    const midY = (cellA.baseY + cellB.baseY) / 2;

                    // Edge direction (along the edge, perpendicular to cell-cell)
                    const edgeDirX = -dy / dist;
                    const edgeDirY = dx / dist;

                    // Normal pointing from B toward A
                    const nx = -dx / dist;
                    const ny = -dy / dist;

                    voronoiEdges.push({
                        cellA: i,
                        cellB: j,
                        midX, midY,
                        dirX: edgeDirX,
                        dirY: edgeDirY,
                        nx, ny,
                        dist
                    });

                    // Map edges to cells with angle for sorting
                    const angleFromA = Math.atan2(cellB.baseY - cellA.baseY, cellB.baseX - cellA.baseX);
                    const angleFromB = Math.atan2(cellA.baseY - cellB.baseY, cellA.baseX - cellB.baseX);

                    cellEdgeMap[i].push({ edgeIdx, neighborIdx: j, angle: angleFromA, side: 'A' });
                    cellEdgeMap[j].push({ edgeIdx, neighborIdx: i, angle: angleFromB, side: 'B' });
                }
            }

            // Sort each cell's edges by angle (counter-clockwise order)
            for (let i = 0; i < cells.length; i++) {
                cellEdgeMap[i].sort((a, b) => a.angle - b.angle);
            }

            // Compute base polygons for centroid reference
            // Use rotated zone bounds
            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                let polygon = zone.bounds.map(p => [...p]);

                for (let j = 0; j < cells.length; j++) {
                    if (i === j) continue;
                    const other = cells[j];
                    const dx = other.baseX - cell.baseX;
                    const dy = other.baseY - cell.baseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 0.001) continue;

                    const midX = (cell.baseX + other.baseX) / 2;
                    const midY = (cell.baseY + other.baseY) / 2;
                    const nx = cell.baseX - other.baseX;
                    const ny = cell.baseY - other.baseY;

                    polygon = clipPolygon(polygon, midX, midY, nx, ny);
                    if (polygon.length < 3) break;
                }

                cell.basePolygon = polygon.length >= 3 ? polygon : null;
                cell.baseCentroid = getPolygonCentroid(cell.basePolygon);
            }

            updateDisplayPolygons();
        }

        // Compute shifted edge as a LINE (point + direction)
        function getShiftedEdge(edge, shift) {
            return {
                // Point on the shifted line
                px: edge.midX + edge.nx * shift,
                py: edge.midY + edge.ny * shift,
                // Direction along the edge (unchanged)
                dx: edge.dirX,
                dy: edge.dirY,
                // Normal (unchanged)
                nx: edge.nx,
                ny: edge.ny
            };
        }

        // Intersect two lines, each defined by point (px,py) and direction (dx,dy)
        function intersectLines(line1, line2) {
            const denom = line1.dx * line2.dy - line1.dy * line2.dx;
            if (Math.abs(denom) < 0.0001) return null; // Parallel

            const t = ((line2.px - line1.px) * line2.dy - (line2.py - line1.py) * line2.dx) / denom;
            return [line1.px + t * line1.dx, line1.py + t * line1.dy];
        }

        // Display polygons with neighbor displacement via seed movement
        // Moving seeds recomputes Voronoi naturally while maintaining perfect tessellation
        function updateDisplayPolygons() {
            const zone = getZoneBounds(false);
            const zoneWithBuffer = getZoneBounds(true);
            const gap = config.gap;

            // Compute TARGET displaced positions based on hovered cell
            // The actual displacement is animated in Cell.update()
            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];

                // Default: return to base position
                cell.targetDisplacedX = cell.baseX;
                cell.targetDisplacedY = cell.baseY;

                // If no cell is hovered, all targets are base position
                if (hoveredCell < 0 || i === hoveredCell) {
                    continue;
                }

                // Push this seed away from the hovered cell
                const hovered = cells[hoveredCell];
                const dx = cell.baseX - hovered.baseX;
                const dy = cell.baseY - hovered.baseY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 1) continue;

                // Use the HOVERED cell's current animated scale for smooth push
                const scaleExtra = Math.max(0, hovered.scale - 1.0);

                // Push amount: configurable falloff distance
                const maxPush = config.maxExpansion * config.displaceRatio;
                const distanceFactor = Math.max(0, 1 - dist / config.displaceFalloff);
                const pushAmount = scaleExtra * maxPush * distanceFactor;

                cell.targetDisplacedX = cell.baseX + (dx / dist) * pushAmount;
                cell.targetDisplacedY = cell.baseY + (dy / dist) * pushAmount;
            }

            // Build array for Voronoi computation
            const displacedSeeds = cells.map(cell => ({
                x: cell.displacedX,
                y: cell.displacedY
            }));

            // Rebuild Voronoi polygons using displaced seeds
            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                const seed = displacedSeeds[i];

                // Start with rotated zone bounds (with buffer)
                let polygon = zoneWithBuffer.bounds.map(p => [...p]);

                // Clip against bisector with each other cell (using displaced seeds)
                for (let j = 0; j < cells.length; j++) {
                    if (i === j) continue;

                    const other = displacedSeeds[j];
                    const dx = other.x - seed.x;
                    const dy = other.y - seed.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 0.001) continue;

                    // Midpoint between displaced seeds
                    const mx = (seed.x + other.x) / 2;
                    const my = (seed.y + other.y) / 2;

                    // Normal pointing toward this cell
                    const nx = -dx / dist;
                    const ny = -dy / dist;

                    polygon = clipPolygon(polygon, mx, my, nx, ny);
                    if (polygon.length < 3) break;
                }

                if (polygon.length < 3) {
                    cell.polygon = cell.basePolygon;
                    cell.displayPolygon = cell.basePolygon;
                    continue;
                }

                // Compute centroid and validate polygon integrity
                const centroid = getPolygonCentroid(polygon);

                // Check polygon area - if it's too small or negative, cell is over-deformed
                let polygonArea = 0;
                for (let k = 0; k < polygon.length; k++) {
                    const k1 = (k + 1) % polygon.length;
                    polygonArea += polygon[k][0] * polygon[k1][1];
                    polygonArea -= polygon[k1][0] * polygon[k][1];
                }
                polygonArea = polygonArea / 2;

                // Get base polygon area for comparison
                let baseArea = 0;
                if (cell.basePolygon) {
                    for (let k = 0; k < cell.basePolygon.length; k++) {
                        const k1 = (k + 1) % cell.basePolygon.length;
                        baseArea += cell.basePolygon[k][0] * cell.basePolygon[k1][1];
                        baseArea -= cell.basePolygon[k1][0] * cell.basePolygon[k][1];
                    }
                    baseArea = Math.abs(baseArea / 2);
                }

                // CRITICAL: If centroid is outside polygon OR area collapsed too much,
                // the cell has flipped inside-out or been over-squeezed
                const minAreaRatio = 0.1; // Don't let cell shrink below 10% of original
                const isInverted = polygonArea < 0;
                const isTooSmall = baseArea > 0 && Math.abs(polygonArea) < baseArea * minAreaRatio;
                const centroidEscaped = !pointInPolygon(centroid.x, centroid.y, polygon);

                if (isInverted || isTooSmall || centroidEscaped) {
                    // Deformation limit reached - use base polygon
                    cell.baseCentroid = getPolygonCentroid(cell.basePolygon);
                    cell.polygon = cell.basePolygon;
                    cell.displayPolygon = cell.basePolygon;
                    continue;
                }

                cell.baseCentroid = centroid;

                // Hit detection uses BASE polygon (stable, doesn't change with animation)
                // This prevents hover fighting when polygons shift
                cell.polygon = cell.basePolygon;

                // Clip to display bounds using rotated zone clip planes
                // Expanding cells get extra buffer
                const scaleExtra = Math.max(0, cell.scale - 1.0);
                const useBuffer = scaleExtra > 0.01;
                const clipZone = useBuffer ? zoneWithBuffer : zone;

                let clipped = polygon;
                for (const plane of clipZone.clipPlanes) {
                    clipped = clipPolygon(clipped, plane.px, plane.py, plane.nx, plane.ny);
                    if (clipped.length < 3) break;
                }

                // Apply uniform gap inset
                cell.displayPolygon = gap > 0 && clipped.length >= 3 ? insetPolygon(clipped, gap / 2) : clipped;
            }
        }

        function clipPolygon(polygon, px, py, nx, ny) {
            const output = [];
            const n = polygon.length;

            for (let i = 0; i < n; i++) {
                const curr = polygon[i];
                const next = polygon[(i + 1) % n];

                const currDist = (curr[0] - px) * nx + (curr[1] - py) * ny;
                const nextDist = (next[0] - px) * nx + (next[1] - py) * ny;

                if (currDist >= 0) {
                    output.push(curr);
                    if (nextDist < 0) {
                        output.push(lineIntersect(curr, next, px, py, nx, ny));
                    }
                } else if (nextDist >= 0) {
                    output.push(lineIntersect(curr, next, px, py, nx, ny));
                }
            }

            return output;
        }

        function lineIntersect(a, b, px, py, nx, ny) {
            const dx = b[0] - a[0];
            const dy = b[1] - a[1];
            const denom = dx * nx + dy * ny;
            if (Math.abs(denom) < 0.0001) return [...a];
            const t = ((px - a[0]) * nx + (py - a[1]) * ny) / denom;
            return [a[0] + t * dx, a[1] + t * dy];
        }

        function getPolygonCentroid(polygon) {
            if (!polygon || polygon.length < 3) return { x: 0, y: 0 };
            let cx = 0, cy = 0;
            for (const p of polygon) {
                cx += p[0];
                cy += p[1];
            }
            return { x: cx / polygon.length, y: cy / polygon.length };
        }

        // Proper polygon inset - offset each edge inward by amount, then find new vertices
        // This creates uniform gaps between adjacent cells
        function insetPolygon(polygon, amount) {
            if (!polygon || polygon.length < 3 || amount <= 0) return polygon;

            const n = polygon.length;

            // Compute signed area to determine winding direction
            let signedArea = 0;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                signedArea += polygon[i][0] * polygon[j][1];
                signedArea -= polygon[j][0] * polygon[i][1];
            }
            // In screen coords (Y down): signedArea > 0 means CW, < 0 means CCW
            // For CW polygon, interior is on RIGHT of edge direction
            // For CCW polygon, interior is on LEFT of edge direction
            const windingSign = signedArea > 0 ? -1 : 1;

            const insetEdges = [];

            // For each edge, compute the inward-offset line
            for (let i = 0; i < n; i++) {
                const p1 = polygon[i];
                const p2 = polygon[(i + 1) % n];

                // Edge direction
                const edx = p2[0] - p1[0];
                const edy = p2[1] - p1[1];
                const len = Math.sqrt(edx * edx + edy * edy);

                if (len < 0.001) continue;

                // Inward normal - perpendicular to edge, direction depends on winding
                // For CCW: inward is to the right of edge direction (dy, -dx)
                // For CW: inward is to the left of edge direction (-dy, dx)
                const nx = windingSign * edy / len;
                const ny = windingSign * -edx / len;

                // Offset the edge inward
                const offsetP1 = [p1[0] + nx * amount, p1[1] + ny * amount];
                const offsetP2 = [p2[0] + nx * amount, p2[1] + ny * amount];

                insetEdges.push({ p1: offsetP1, p2: offsetP2, nx, ny });
            }

            if (insetEdges.length < 3) return polygon;

            // Compute new vertices as intersections of consecutive offset edges
            const result = [];
            for (let i = 0; i < insetEdges.length; i++) {
                const e1 = insetEdges[i];
                const e2 = insetEdges[(i + 1) % insetEdges.length];

                // Find intersection of two lines
                const intersection = lineLineIntersect(e1.p1, e1.p2, e2.p1, e2.p2);
                if (intersection) {
                    result.push(intersection);
                }
            }

            // Validate result - check if polygon collapsed or inverted
            if (result.length < 3) return polygon;

            // Check that result area is smaller than original (sanity check)
            let resultArea = 0;
            for (let i = 0; i < result.length; i++) {
                const j = (i + 1) % result.length;
                resultArea += result[i][0] * result[j][1];
                resultArea -= result[j][0] * result[i][1];
            }
            resultArea = Math.abs(resultArea);
            const origArea = Math.abs(signedArea);

            // If result is larger than original or collapsed to nothing, return original
            if (resultArea > origArea * 1.1 || resultArea < 1) return polygon;

            return result;
        }

        // Line-line intersection helper
        function lineLineIntersect(p1, p2, p3, p4) {
            const x1 = p1[0], y1 = p1[1];
            const x2 = p2[0], y2 = p2[1];
            const x3 = p3[0], y3 = p3[1];
            const x4 = p4[0], y4 = p4[1];

            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 0.0001) {
                // Lines are parallel, return midpoint of shared region
                return [(p2[0] + p3[0]) / 2, (p2[1] + p3[1]) / 2];
            }

            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            return [x1 + t * (x2 - x1), y1 + t * (y2 - y1)];
        }

        // Simple rect clipping
        function clipToRect(polygon, left, top, right, bottom) {
            if (!polygon || polygon.length < 3) return polygon;

            let result = polygon;
            result = clipPolygon(result, left, top, 1, 0);      // left
            result = clipPolygon(result, right, top, -1, 0);    // right
            result = clipPolygon(result, left, top, 0, 1);      // top
            result = clipPolygon(result, left, bottom, 0, -1);  // bottom

            return result;
        }

        // ========== POLYGON SIMPLIFICATION ==========
        // Removes nearly-collinear vertices and merges close points
        // This helps corner rounding work better on clipped polygons
        // More aggressive simplification: larger minEdgeLength, stricter collinearity
        function simplifyPolygon(polygon, minEdgeLength = 20, collinearThreshold = 0.95) {
            if (!polygon || polygon.length < 3) return polygon;

            // First pass: merge vertices that are too close together
            let simplified = [];
            for (let i = 0; i < polygon.length; i++) {
                const curr = polygon[i];
                const last = simplified[simplified.length - 1];

                if (!last) {
                    simplified.push(curr);
                    continue;
                }

                const dist = Math.sqrt((curr[0] - last[0]) ** 2 + (curr[1] - last[1]) ** 2);
                if (dist >= minEdgeLength) {
                    simplified.push(curr);
                } else {
                    // Merge: keep the midpoint
                    simplified[simplified.length - 1] = [(curr[0] + last[0]) / 2, (curr[1] + last[1]) / 2];
                }
            }

            // Check first and last vertex distance
            if (simplified.length > 2) {
                const first = simplified[0];
                const last = simplified[simplified.length - 1];
                const dist = Math.sqrt((first[0] - last[0]) ** 2 + (first[1] - last[1]) ** 2);
                if (dist < minEdgeLength) {
                    simplified[0] = [(first[0] + last[0]) / 2, (first[1] + last[1]) / 2];
                    simplified.pop();
                }
            }

            if (simplified.length < 3) return polygon;

            // Second pass: remove nearly-collinear points
            const result = [];
            const n = simplified.length;

            for (let i = 0; i < n; i++) {
                const prev = simplified[(i - 1 + n) % n];
                const curr = simplified[i];
                const next = simplified[(i + 1) % n];

                // Calculate vectors
                const v1x = curr[0] - prev[0];
                const v1y = curr[1] - prev[1];
                const v2x = next[0] - curr[0];
                const v2y = next[1] - curr[1];

                const len1 = Math.sqrt(v1x * v1x + v1y * v1y);
                const len2 = Math.sqrt(v2x * v2x + v2y * v2y);

                if (len1 < 0.001 || len2 < 0.001) {
                    continue; // Skip degenerate edges
                }

                // Dot product of normalized vectors
                const dot = (v1x * v2x + v1y * v2y) / (len1 * len2);

                // If vectors are nearly parallel (dot close to 1), skip this vertex
                if (dot < collinearThreshold) {
                    result.push(curr);
                }
            }

            return result.length >= 3 ? result : polygon;
        }

        // ========== ROUNDED CORNERS ==========
        function drawRoundedPolygon(ctx, polygon, radius) {
            if (!polygon || polygon.length < 3) return;

            // Calculate polygon area to detect degenerate cases
            let area = 0;
            for (let i = 0; i < polygon.length; i++) {
                const j = (i + 1) % polygon.length;
                area += polygon[i][0] * polygon[j][1];
                area -= polygon[j][0] * polygon[i][1];
            }
            area = Math.abs(area) / 2;

            // If polygon is too small, just draw it without rounding
            if (area < 100 || radius <= 0) {
                ctx.beginPath();
                ctx.moveTo(polygon[0][0], polygon[0][1]);
                for (let i = 1; i < polygon.length; i++) {
                    ctx.lineTo(polygon[i][0], polygon[i][1]);
                }
                ctx.closePath();
                return;
            }

            const n = polygon.length;

            // Pre-calculate all corner radii to ensure consistency
            const radii = [];
            for (let i = 0; i < n; i++) {
                const prev = polygon[(i - 1 + n) % n];
                const curr = polygon[i];
                const next = polygon[(i + 1) % n];

                const dist1 = Math.sqrt((prev[0] - curr[0]) ** 2 + (prev[1] - curr[1]) ** 2);
                const dist2 = Math.sqrt((next[0] - curr[0]) ** 2 + (next[1] - curr[1]) ** 2);

                // Limit radius to 50% of the shorter edge - allows corners to meet at edge midpoints
                // arcTo() handles overflow gracefully, so this is safe even for tight corners
                const maxRadius = Math.min(dist1, dist2) * 0.5;
                radii[i] = Math.max(0, Math.min(radius, maxRadius));
            }

            ctx.beginPath();

            // Find first valid starting point
            let started = false;
            for (let i = 0; i < n; i++) {
                const prev = polygon[(i - 1 + n) % n];
                const curr = polygon[i];
                const next = polygon[(i + 1) % n];
                const r = radii[i];

                let dx1 = prev[0] - curr[0];
                let dy1 = prev[1] - curr[1];
                let dx2 = next[0] - curr[0];
                let dy2 = next[1] - curr[1];

                const dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

                if (r < 0.5 || dist1 < 0.5 || dist2 < 0.5) {
                    // Sharp corner - no rounding
                    if (!started) {
                        ctx.moveTo(curr[0], curr[1]);
                        started = true;
                    } else {
                        ctx.lineTo(curr[0], curr[1]);
                    }
                } else {
                    // Normalize
                    dx1 /= dist1; dy1 /= dist1;
                    dx2 /= dist2; dy2 /= dist2;

                    // Points where the arc starts and ends
                    const startX = curr[0] + dx1 * r;
                    const startY = curr[1] + dy1 * r;
                    const endX = curr[0] + dx2 * r;
                    const endY = curr[1] + dy2 * r;

                    if (!started) {
                        ctx.moveTo(startX, startY);
                        started = true;
                    } else {
                        ctx.lineTo(startX, startY);
                    }

                    // Draw arc using arcTo
                    ctx.arcTo(curr[0], curr[1], endX, endY, r);
                }
            }

            ctx.closePath();
        }

        // ========== INITIALIZATION ==========
        function init() {
            canvas = document.getElementById('voronoiCanvas');
            ctx = canvas.getContext('2d');
            tooltip = document.getElementById('tooltip');

            resize();
            generateCells();
            setupEvents();
            animate(0);
        }

        function resize() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;

            width = rect.width;
            height = rect.height;

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            if (cells.length > 0) {
                generateCells();
            }
        }

        function generateCells() {
            cells = [];

            // Get zone bounds for cell placement
            const zone = getZoneBounds(false);
            const bounds = zone.cellBounds;

            // Ensure valid bounds
            const xMin = Math.max(40, bounds.xMin);
            const xMax = Math.min(width - 40, bounds.xMax);
            const yMin = Math.max(40, bounds.yMin);
            const yMax = Math.min(height - 40, bounds.yMax);

            const contentWidth = Math.max(100, xMax - xMin);
            const contentHeight = Math.max(100, yMax - yMin);
            const minDist = Math.sqrt((contentWidth * contentHeight) / config.cellCount) * 0.6;

            const points = [];
            let attempts = 0;

            // Generate cell positions within rotated zone
            while (points.length < config.cellCount && attempts < 2000) {
                const x = xMin + Math.random() * contentWidth;
                const y = yMin + Math.random() * contentHeight;

                // Check if point is inside the rotated zone
                let insideZone = true;
                for (const plane of zone.clipPlanes) {
                    const dist = (x - plane.px) * plane.nx + (y - plane.py) * plane.ny;
                    if (dist < -20) { // 20px margin from edge
                        insideZone = false;
                        break;
                    }
                }

                if (!insideZone) {
                    attempts++;
                    continue;
                }

                let valid = true;
                for (const p of points) {
                    const dx = p[0] - x, dy = p[1] - y;
                    if (dx * dx + dy * dy < minDist * minDist * 0.5) {
                        valid = false;
                        break;
                    }
                }

                if (valid) points.push([x, y]);
                attempts++;
            }

            // Fill remaining with random positions if needed
            while (points.length < config.cellCount) {
                const x = xMin + Math.random() * contentWidth;
                const y = yMin + Math.random() * contentHeight;
                points.push([x, y]);
            }

            // Create visible cells
            for (let i = 0; i < points.length; i++) {
                const cell = new Cell(points[i][0], points[i][1], i);
                cell.createPattern();
                cells.push(cell);
            }

            // Compute base Voronoi ONCE - shapes are fixed from here
            computeBaseVoronoi();
            updateDisplayPolygons();
        }

        // ========== EVENTS ==========
        function setupEvents() {
            window.addEventListener('resize', () => {
                resize();
                // Recompute base Voronoi on resize
                computeBaseVoronoi();
                updateDisplayPolygons();
            });

            canvas.addEventListener('mousemove', handlePointerMove);
            canvas.addEventListener('mouseleave', handlePointerLeave);
            canvas.addEventListener('click', handleClick);

            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);

            setupControls();
        }

        function handlePointerMove(e) {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            updateHover();
            updateTooltip(e.clientX, e.clientY);
        }

        function handlePointerLeave() {
            mouseX = -9999;
            mouseY = -9999;
            hoveredCell = -1;
            cells.forEach(c => {
                c.targetZoom = config.nonHoverImageZoom;
                c.targetOpacity = config.nonHoveredOpacity;
            });
            tooltip.classList.remove('visible');
        }

        function handleClick() {
            if (hoveredCell >= 0 && cells[hoveredCell]) {
                const cell = cells[hoveredCell];
                if (cell.link) {
                    console.log('Navigate to:', cell.link);
                }
            }
        }

        let touchStartCell = -1;
        let touchStartTime = 0;

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            updateHover();
            touchStartCell = hoveredCell;
            touchStartTime = Date.now();
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            updateHover();
        }

        function handleTouchEnd() {
            if (Date.now() - touchStartTime < 300 && touchStartCell === hoveredCell && hoveredCell >= 0) {
                handleClick();
            }
            setTimeout(() => {
                mouseX = -9999;
                mouseY = -9999;
                hoveredCell = -1;
                cells.forEach(c => {
                    c.targetZoom = config.nonHoverImageZoom;
                    c.targetOpacity = config.nonHoveredOpacity;
                });
            }, 100);
        }

        function updateHover() {
            let found = -1;

            // Use polygon surface for hit detection
            for (let i = 0; i < cells.length; i++) {
                if (cells[i].polygon && pointInPolygon(mouseX, mouseY, cells[i].polygon)) {
                    found = i;
                    break;
                }
            }

            if (found !== hoveredCell) {
                if (hoveredCell >= 0) {
                    cells[hoveredCell].targetZoom = config.nonHoverImageZoom;
                    cells[hoveredCell].targetOpacity = config.nonHoveredOpacity;
                }
                hoveredCell = found;
                if (hoveredCell >= 0) {
                    cells[hoveredCell].targetZoom = 1.0;
                    cells[hoveredCell].targetOpacity = 1.0;
                }
            }

            canvas.style.cursor = hoveredCell >= 0 ? 'pointer' : 'default';
        }

        function pointInPolygon(x, y, polygon) {
            if (!polygon || polygon.length < 3) return false;

            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];

                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function updateTooltip(clientX, clientY) {
            if (hoveredCell >= 0 && cells[hoveredCell]) {
                const cell = cells[hoveredCell];
                tooltip.textContent = cell.title;
                tooltip.classList.add('visible');

                const rect = canvas.parentElement.getBoundingClientRect();
                const cursorX = clientX - rect.left;
                const cursorY = clientY - rect.top;

                // Direction from cell center to cursor
                const dx = cursorX - cell.x;
                const dy = cursorY - cell.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Position tooltip on opposite side of cursor from cell center
                // (in the "shadow" cast by cursor, away from the cell center "sun")
                const offset = 50;
                let tooltipX, tooltipY;

                if (dist > 1) {
                    // Normalize and extend in same direction (away from center)
                    tooltipX = cursorX + (dx / dist) * offset;
                    tooltipY = cursorY + (dy / dist) * offset;
                } else {
                    tooltipX = cursorX + offset;
                    tooltipY = cursorY;
                }

                // Get tooltip dimensions for boundary checking
                const tooltipRect = tooltip.getBoundingClientRect();
                const tw = tooltipRect.width || 100;
                const th = tooltipRect.height || 30;

                // Keep tooltip in bounds
                tooltipX = Math.max(5, Math.min(width - tw - 5, tooltipX));
                tooltipY = Math.max(5, Math.min(height - th - 5, tooltipY));

                tooltip.style.left = tooltipX + 'px';
                tooltip.style.top = tooltipY + 'px';
            } else {
                tooltip.classList.remove('visible');
            }
        }

        function setupControls() {
            // Cell count
            const cellCountEl = document.getElementById('cellCount');
            const cellCountVal = document.getElementById('cellCountVal');
            cellCountEl.addEventListener('input', () => {
                config.cellCount = +cellCountEl.value;
                cellCountVal.textContent = config.cellCount;
            });
            cellCountEl.addEventListener('change', generateCells);

            // Gap
            const gapEl = document.getElementById('gap');
            const gapVal = document.getElementById('gapVal');
            gapEl.addEventListener('input', () => {
                config.gap = +gapEl.value;
                gapVal.textContent = config.gap;
                // Gap is applied in updateDisplayPolygons() every frame
            });

            // Corner radius
            const cornerEl = document.getElementById('cornerRadius');
            const cornerVal = document.getElementById('cornerRadiusVal');
            cornerEl.addEventListener('input', () => {
                config.cornerRadius = +cornerEl.value;
                cornerVal.textContent = config.cornerRadius;
            });

            // Max Expansion (inflation)
            const maxExpansionEl = document.getElementById('maxExpansion');
            const maxExpansionVal = document.getElementById('maxExpansionVal');
            maxExpansionEl.addEventListener('input', () => {
                config.maxExpansion = +maxExpansionEl.value;
                maxExpansionVal.textContent = config.maxExpansion;
            });

            // In Speed - how fast cells expand on hover (1-100 scale)
            const expansionSpeedEl = document.getElementById('expansionSpeed');
            const expansionSpeedVal = document.getElementById('expansionSpeedVal');
            expansionSpeedEl.addEventListener('input', () => {
                config.expansionSpeed = +expansionSpeedEl.value;
                expansionSpeedVal.textContent = config.expansionSpeed;
            });

            // Out Speed - how fast cells shrink back after hover ends (1-100 scale)
            const retractionSpeedEl = document.getElementById('retractionSpeed');
            const retractionSpeedVal = document.getElementById('retractionSpeedVal');
            retractionSpeedEl.addEventListener('input', () => {
                config.retractionSpeed = +retractionSpeedEl.value;
                retractionSpeedVal.textContent = config.retractionSpeed;
            });

            // Displace Ratio - 0 = no neighbor push, 1 = max neighbor push
            const displaceRatioEl = document.getElementById('displaceRatio');
            const displaceRatioVal = document.getElementById('displaceRatioVal');
            displaceRatioEl.addEventListener('input', () => {
                config.displaceRatio = +displaceRatioEl.value / 100;
                displaceRatioVal.textContent = config.displaceRatio.toFixed(2);
            });

            // Displacement Falloff - how far displacement reaches (lower = local, higher = global)
            const displaceFalloffEl = document.getElementById('displaceFalloff');
            const displaceFalloffVal = document.getElementById('displaceFalloffVal');
            displaceFalloffEl.addEventListener('input', () => {
                config.displaceFalloff = +displaceFalloffEl.value;
                displaceFalloffVal.textContent = config.displaceFalloff;
            });

            // Non-Hovered Opacity
            const nonHoveredOpacityEl = document.getElementById('nonHoveredOpacity');
            const nonHoveredOpacityVal = document.getElementById('nonHoveredOpacityVal');
            nonHoveredOpacityEl.addEventListener('input', () => {
                config.nonHoveredOpacity = +nonHoveredOpacityEl.value / 100;
                nonHoveredOpacityVal.textContent = config.nonHoveredOpacity.toFixed(2);
                cells.forEach((c, i) => {
                    if (i !== hoveredCell) {
                        c.targetOpacity = config.nonHoveredOpacity;
                    }
                });
            });

            // Non-Hover Image Zoom
            const nonHoverImageZoomEl = document.getElementById('nonHoverImageZoom');
            const nonHoverImageZoomVal = document.getElementById('nonHoverImageZoomVal');
            nonHoverImageZoomEl.addEventListener('input', () => {
                config.nonHoverImageZoom = +nonHoverImageZoomEl.value / 10;
                nonHoverImageZoomVal.textContent = config.nonHoverImageZoom.toFixed(1);
                cells.forEach((c, i) => {
                    if (i !== hoveredCell) {
                        c.targetZoom = config.nonHoverImageZoom;
                    }
                });
            });

            // Image Zoom Speed
            const imageZoomSpeedEl = document.getElementById('imageZoomSpeed');
            const imageZoomSpeedVal = document.getElementById('imageZoomSpeedVal');
            imageZoomSpeedEl.addEventListener('input', () => {
                config.imageZoomSpeed = +imageZoomSpeedEl.value;
                imageZoomSpeedVal.textContent = config.imageZoomSpeed;
            });

            // Content Zone Controls
            // Zone Margin
            const contentZoneMarginEl = document.getElementById('contentZoneMargin');
            const contentZoneMarginVal = document.getElementById('contentZoneMarginVal');
            contentZoneMarginEl.addEventListener('input', () => {
                config.contentZoneMargin = +contentZoneMarginEl.value / 100;
                contentZoneMarginVal.textContent = contentZoneMarginEl.value + '%';
            });
            contentZoneMarginEl.addEventListener('change', generateCells);

            // Zone Rotation
            const contentZoneRotationEl = document.getElementById('contentZoneRotation');
            const contentZoneRotationVal = document.getElementById('contentZoneRotationVal');
            contentZoneRotationEl.addEventListener('input', () => {
                config.contentZoneRotation = +contentZoneRotationEl.value;
                contentZoneRotationVal.textContent = config.contentZoneRotation + '°';
            });
            contentZoneRotationEl.addEventListener('change', generateCells);

            const bleedBufferEl = document.getElementById('bleedBuffer');
            const bleedBufferVal = document.getElementById('bleedBufferVal');
            bleedBufferEl.addEventListener('input', () => {
                config.bleedBuffer = +bleedBufferEl.value;
                bleedBufferVal.textContent = config.bleedBuffer;
                // Buffer affects base Voronoi bounds - need to recompute
                computeBaseVoronoi();
            });

            // Buttons
            document.getElementById('regenerate').addEventListener('click', generateCells);

            const toggleContentZone = document.getElementById('toggleContentZone');
            toggleContentZone.classList.toggle('active', config.contentZoneEnabled);
            toggleContentZone.addEventListener('click', () => {
                config.contentZoneEnabled = !config.contentZoneEnabled;
                toggleContentZone.classList.toggle('active', config.contentZoneEnabled);
                generateCells();
            });

            const toggleDebug = document.getElementById('toggleDebug');
            toggleDebug.addEventListener('click', () => {
                config.debugMode = !config.debugMode;
                toggleDebug.classList.toggle('active', config.debugMode);
            });

            const loadUnsplash = document.getElementById('loadUnsplash');
            loadUnsplash.addEventListener('click', loadUnsplashImages);
        }

        // ========== UNSPLASH IMAGES ==========
        function loadUnsplashImages() {
            const btn = document.getElementById('loadUnsplash');
            btn.textContent = 'Loading...';
            btn.disabled = true;

            let loaded = 0;
            const total = cells.length;

            cells.forEach((cell, i) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                // Use random seed for variety, sig for cache busting
                img.src = `https://picsum.photos/300/300?random=${i}&t=${Date.now()}`;

                img.onload = () => {
                    const size = 300;
                    const patternCanvas = document.createElement('canvas');
                    patternCanvas.width = size;
                    patternCanvas.height = size;
                    const pctx = patternCanvas.getContext('2d');

                    // Draw image covering the canvas
                    pctx.drawImage(img, 0, 0, size, size);

                    cell.pattern = patternCanvas;
                    loaded++;

                    if (loaded >= total) {
                        btn.textContent = 'Unsplash';
                        btn.disabled = false;
                    }
                };

                img.onerror = () => {
                    loaded++;
                    if (loaded >= total) {
                        btn.textContent = 'Unsplash';
                        btn.disabled = false;
                    }
                };
            });
        }

        // ========== PHYSICS ==========
        function updatePhysics(dt) {
            // Scale factor: 1.0 = normal, 1.0 + maxExpansion/300 = expanded
            const expandedScale = 1.0 + config.maxExpansion / 300;

            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                cell.targetScale = (i === hoveredCell) ? expandedScale : 1.0;
                cell.update(dt, i === hoveredCell);
            }

            // Update display polygons - uses animated displacedX/Y from each cell
            updateDisplayPolygons();
        }

        // ========== RENDERING ==========
        function render() {
            ctx.clearRect(0, 0, width, height);

            // Helper to draw a single cell
            function drawCell(i) {
                const cell = cells[i];
                const polygon = cell.displayPolygon;

                if (!polygon || polygon.length < 3) return;

                ctx.save();

                // Apply opacity
                ctx.globalAlpha = cell.opacity;

                // Create rounded clipping path
                drawRoundedPolygon(ctx, polygon, config.cornerRadius);
                ctx.clip();

                // Calculate bounds
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const p of polygon) {
                    minX = Math.min(minX, p[0]);
                    maxX = Math.max(maxX, p[0]);
                    minY = Math.min(minY, p[1]);
                    maxY = Math.max(maxY, p[1]);
                }

                const cellW = maxX - minX;
                const cellH = maxY - minY;
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                // Draw pattern with zoom
                if (cell.pattern) {
                    const zoom = cell.zoom;
                    const size = Math.max(cellW, cellH) * 1.4 * zoom;
                    ctx.drawImage(
                        cell.pattern,
                        centerX - size / 2,
                        centerY - size / 2,
                        size,
                        size
                    );
                }

                ctx.restore();

                // Draw border
                drawRoundedPolygon(ctx, polygon, config.cornerRadius);

                if (i === hoveredCell) {
                    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'rgba(255,255,255,0.5)';
                    ctx.shadowBlur = 15;
                } else {
                    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                    ctx.lineWidth = 1;
                    ctx.shadowBlur = 0;
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Draw non-hovered cells first
            for (let i = 0; i < cells.length; i++) {
                if (i !== hoveredCell) {
                    drawCell(i);
                }
            }

            // Draw hovered cell LAST (on top) so it can overlap neighbors
            if (hoveredCell >= 0 && hoveredCell < cells.length) {
                drawCell(hoveredCell);
            }

            // No mask - cells themselves define the boundary
            // Non-hovered cells are clipped to soft bounds
            // Hovered cell extends into buffer - what you see is what you get

            // Debug mode
            if (config.debugMode) {
                if (config.contentZoneEnabled) {
                    const zone = getZoneBounds(false);
                    const zoneWithBuffer = getZoneBounds(true);

                    // Draw buffer zone (outer boundary)
                    ctx.strokeStyle = 'rgba(255, 150, 50, 1)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(zoneWithBuffer.bounds[0][0], zoneWithBuffer.bounds[0][1]);
                    for (let i = 1; i < zoneWithBuffer.bounds.length; i++) {
                        ctx.lineTo(zoneWithBuffer.bounds[i][0], zoneWithBuffer.bounds[i][1]);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    // Draw content zone (inner boundary)
                    ctx.strokeStyle = 'rgba(100, 255, 100, 1)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 4]);
                    ctx.beginPath();
                    ctx.moveTo(zone.bounds[0][0], zone.bounds[0][1]);
                    for (let i = 1; i < zone.bounds.length; i++) {
                        ctx.lineTo(zone.bounds[i][0], zone.bounds[i][1]);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Label
                    ctx.font = '12px monospace';
                    ctx.fillStyle = 'rgba(255, 150, 50, 1)';
                    ctx.fillText('BUFFER EDGE (orange)', 10, 20);
                    ctx.fillStyle = 'rgba(100, 255, 100, 1)';
                    ctx.fillText('CONTENT ZONE (green) - Angle: ' + zone.snappedAngle + '° (snapped from ' + config.contentZoneRotation + '°)', 10, 40);
                }

                // Draw cell debug info
                for (const cell of cells) {
                    const polygon = cell.displayPolygon;
                    const centroid = cell.baseCentroid || { x: cell.baseX, y: cell.baseY };

                    // Draw seed displacement (line from base to displaced position)
                    if (cell.displacedX !== undefined) {
                        const dx = cell.displacedX - cell.baseX;
                        const dy = cell.displacedY - cell.baseY;
                        const displacement = Math.sqrt(dx * dx + dy * dy);

                        if (displacement > 1) {
                            // Draw line showing displacement
                            ctx.strokeStyle = 'rgba(255, 100, 100, 0.9)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(cell.baseX, cell.baseY);
                            ctx.lineTo(cell.displacedX, cell.displacedY);
                            ctx.stroke();

                            // Draw displaced position (red dot)
                            ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                            ctx.beginPath();
                            ctx.arc(cell.displacedX, cell.displacedY, 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Draw lines from each corner to cell center
                    if (polygon && polygon.length >= 3) {
                        ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([3, 3]);
                        for (const corner of polygon) {
                            ctx.beginPath();
                            ctx.moveTo(corner[0], corner[1]);
                            ctx.lineTo(centroid.x, centroid.y);
                            ctx.stroke();
                        }
                        ctx.setLineDash([]);

                        // Draw corner dots
                        ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
                        for (const corner of polygon) {
                            ctx.beginPath();
                            ctx.arc(corner[0], corner[1], 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Base seed position (white dot)
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(cell.baseX, cell.baseY, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Centroid (shows where polygon center actually is)
                    const dotSize = 4 + (cell.scale - 1) * 20;
                    ctx.fillStyle = cell.scale > 1.01 ? 'rgba(255,200,100,0.9)' : 'rgba(100,200,255,0.7)';
                    ctx.beginPath();
                    ctx.arc(centroid.x, centroid.y, dotSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // ========== ANIMATION LOOP ==========
        function animate(time) {
            const dt = Math.min((time - lastTime) / 16, 3);
            lastTime = time;

            updatePhysics(dt);
            render();

            animationId = requestAnimationFrame(animate);
        }

        // ========== START ==========
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    })();
    </script>
</body>
</html>
