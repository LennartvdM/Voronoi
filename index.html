<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Interactive Voronoi Grid</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #voronoiCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            pointer-events: none;
            opacity: 0;
            transform: translateY(5px);
            transition: opacity 0.2s, transform 0.2s;
            z-index: 100;
            white-space: nowrap;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .controls {
            background: rgba(20, 20, 35, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255,255,255,0.1);
            padding: 12px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px 16px;
            align-items: flex-end;
        }

        .control-section {
            display: contents;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 100px;
        }

        .control-group.wide {
            min-width: 130px;
        }

        .control-group label {
            font-size: 9px;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        input[type="range"] {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.15);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(99,102,241,0.4);
            transition: transform 0.15s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .control-value {
            font-size: 11px;
            color: #fff;
            font-weight: 600;
            min-width: 28px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        .btn {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: #fff;
            box-shadow: 0 4px 15px rgba(99,102,241,0.3);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(99,102,241,0.4);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.15);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.15);
        }

        .btn-secondary.active {
            background: rgba(99,102,241,0.3);
            border-color: rgba(99,102,241,0.5);
        }

        .divider {
            width: 1px;
            height: 36px;
            background: rgba(255,255,255,0.1);
        }

        @media (max-width: 1100px) {
            .control-group.hide-tablet {
                display: none;
            }
        }

        @media (max-width: 800px) {
            .controls {
                padding: 10px 12px;
                gap: 10px 12px;
            }
            .control-group.hide-mobile {
                display: none;
            }
            .btn-group {
                width: 100%;
                margin-left: 0;
                justify-content: flex-end;
            }
            .divider {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="canvas-container">
            <canvas id="voronoiCanvas"></canvas>
            <div class="tooltip" id="tooltip"></div>
        </div>
        <div class="controls">
            <!-- Grid Settings -->
            <div class="control-group">
                <label>Cells</label>
                <div class="control-row">
                    <input type="range" id="cellCount" min="4" max="30" value="12">
                    <span class="control-value" id="cellCountVal">12</span>
                </div>
            </div>
            <div class="control-group">
                <label>Gap</label>
                <div class="control-row">
                    <input type="range" id="gap" min="0" max="30" value="4">
                    <span class="control-value" id="gapVal">4</span>
                </div>
            </div>
            <div class="control-group">
                <label>Corners</label>
                <div class="control-row">
                    <input type="range" id="cornerRadius" min="0" max="40" value="12">
                    <span class="control-value" id="cornerRadiusVal">12</span>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Hover Effect -->
            <div class="control-group">
                <label>Inflation</label>
                <div class="control-row">
                    <input type="range" id="maxExpansion" min="0" max="400" value="150">
                    <span class="control-value" id="maxExpansionVal">150</span>
                </div>
            </div>
            <div class="control-group">
                <label>Speed</label>
                <div class="control-row">
                    <input type="range" id="expansionSpeed" min="0" max="100" value="50">
                    <span class="control-value" id="expansionSpeedVal">0.025</span>
                </div>
            </div>
            <div class="control-group">
                <label>Displace</label>
                <div class="control-row">
                    <input type="range" id="displaceRatio" min="0" max="100" value="50">
                    <span class="control-value" id="displaceRatioVal">0.50</span>
                </div>
            </div>
            <div class="control-group">
                <label>Dim Others</label>
                <div class="control-row">
                    <input type="range" id="nonHoveredOpacity" min="0" max="100" value="60">
                    <span class="control-value" id="nonHoveredOpacityVal">0.60</span>
                </div>
            </div>
            <div class="control-group hide-mobile">
                <label>Image Zoom</label>
                <div class="control-row">
                    <input type="range" id="nonHoverImageZoom" min="10" max="80" value="17" step="1">
                    <span class="control-value" id="nonHoverImageZoomVal">1.7</span>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Content Zone -->
            <div class="control-group">
                <label>Zone Top</label>
                <div class="control-row">
                    <input type="range" id="contentZoneTop" min="0" max="40" value="15">
                    <span class="control-value" id="contentZoneTopVal">15%</span>
                </div>
            </div>
            <div class="control-group">
                <label>Zone Bottom</label>
                <div class="control-row">
                    <input type="range" id="contentZoneBottom" min="0" max="40" value="15">
                    <span class="control-value" id="contentZoneBottomVal">15%</span>
                </div>
            </div>
            <div class="control-group hide-tablet">
                <label>Bleed Buffer</label>
                <div class="control-row">
                    <input type="range" id="bleedBuffer" min="20" max="200" value="80">
                    <span class="control-value" id="bleedBufferVal">80</span>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Buttons -->
            <div class="btn-group">
                <button class="btn btn-secondary" id="toggleContentZone">Zone</button>
                <button class="btn btn-secondary" id="toggleDebug">Debug</button>
                <button class="btn btn-secondary" id="loadUnsplash">Unsplash</button>
                <button class="btn btn-primary" id="regenerate">Regenerate</button>
            </div>
        </div>
    </div>

    <script>
    (function() {
        'use strict';

        // ========== CONFIGURATION ==========
        const config = {
            // Grid settings
            cellCount: 12,
            gap: 4,
            cornerRadius: 12,

            // Inflation system
            maxExpansion: 150,           // How much the hovered cell inflates (affects neighbor push)
            expansionSpeed: 0.025,       // How fast cells inflate/deflate (0 = inert, 0.05 = fast)
            displaceRatio: 0.5,          // 0 = no neighbor push, 1 = max neighbor push

            // Visual transitions
            nonHoverImageZoom: 1.7,      // Non-hover image zoom level
            imageZoomSpeed: 0.12,        // How fast image zoom transitions
            nonHoveredOpacity: 0.6,      // Opacity for non-hovered cells
            opacityTransitionSpeed: 0.15, // How fast opacity transitions

            // Toggles
            physicsEnabled: true,
            debugMode: false,

            // Content zone / soft boundary
            contentZoneEnabled: true,    // Enable/disable content zone
            contentZoneTop: 0.15,        // Top margin as fraction of height
            contentZoneBottom: 0.15,     // Bottom margin as fraction of height
            bleedBuffer: 80              // Pixel buffer beyond content zone (how far hovered cell can extend)
        };

        // ========== SAMPLE DATA ==========
        const cellData = [
            { title: 'Cosmic Dreams', link: '#cosmic', color: '#6366f1' },
            { title: 'Ocean Depths', link: '#ocean', color: '#06b6d4' },
            { title: 'Forest Whispers', link: '#forest', color: '#10b981' },
            { title: 'Solar Flare', link: '#solar', color: '#f59e0b' },
            { title: 'Cherry Blossom', link: '#cherry', color: '#ec4899' },
            { title: 'Arctic Aurora', link: '#arctic', color: '#8b5cf6' },
            { title: 'Desert Gold', link: '#desert', color: '#eab308' },
            { title: 'Midnight Jazz', link: '#jazz', color: '#3b82f6' },
            { title: 'Ember Glow', link: '#ember', color: '#ef4444' },
            { title: 'Mint Fresh', link: '#mint', color: '#14b8a6' },
            { title: 'Lavender Fields', link: '#lavender', color: '#a855f7' },
            { title: 'Coral Reef', link: '#coral', color: '#f97316' },
            { title: 'Storm Cloud', link: '#storm', color: '#64748b' },
            { title: 'Neon Nights', link: '#neon', color: '#d946ef' },
            { title: 'Sage Garden', link: '#sage', color: '#84cc16' },
            { title: 'Ruby Dreams', link: '#ruby', color: '#dc2626' },
            { title: 'Sapphire Sky', link: '#sapphire', color: '#2563eb' },
            { title: 'Amber Waves', link: '#amber', color: '#d97706' },
            { title: 'Violet Hour', link: '#violet', color: '#7c3aed' },
            { title: 'Teal Depths', link: '#teal', color: '#0d9488' },
            { title: 'Rose Petals', link: '#rose', color: '#e11d48' },
            { title: 'Lime Zest', link: '#lime', color: '#65a30d' },
            { title: 'Indigo Night', link: '#indigo', color: '#4f46e5' },
            { title: 'Peach Sunset', link: '#peach', color: '#fb923c' },
            { title: 'Cyan Wave', link: '#cyan', color: '#22d3d8' },
            { title: 'Magenta Pulse', link: '#magenta', color: '#c026d3' },
            { title: 'Bronze Age', link: '#bronze', color: '#a16207' },
            { title: 'Steel Blue', link: '#steel', color: '#475569' },
            { title: 'Crimson Tide', link: '#crimson', color: '#be123c' },
            { title: 'Emerald City', link: '#emerald', color: '#059669' }
        ];

        // ========== STATE ==========
        let canvas, ctx;
        let width, height;
        let cells = [];
        let hoveredCell = -1;
        let mouseX = -9999, mouseY = -9999;
        let tooltip;
        let animationId;
        let lastTime = 0;

        // ========== CELL CLASS ==========
        class Cell {
            constructor(x, y, index) {
                this.index = index;
                this.baseX = x;
                this.baseY = y;
                this.x = x;
                this.y = y;

                // Simple scale-based animation - no displacement physics
                this.scale = 1.0;          // Current scale (1.0 = normal)
                this.targetScale = 1.0;    // Target scale

                this.basePolygon = null;   // Computed once at init - NEVER changes
                this.baseCentroid = null;  // Center of base polygon
                this.polygon = null;       // For hit testing
                this.displayPolygon = null; // What gets rendered

                this.zoom = config.nonHoverImageZoom;
                this.targetZoom = config.nonHoverImageZoom;
                this.opacity = config.nonHoveredOpacity;
                this.targetOpacity = config.nonHoveredOpacity;

                const data = cellData[index % cellData.length];
                this.title = data.title;
                this.link = data.link;
                this.color = data.color;
                this.pattern = null;
            }

            update(dt, isHovered) {
                // Smooth scale transition - frame-rate independent lerp
                // Using exponential decay: value += (target - value) * (1 - e^(-speed * dt))
                const speed = config.expansionSpeed;
                if (speed > 0.0001) {
                    const diff = this.targetScale - this.scale;
                    // Snap to target when very close (reduces jitter)
                    if (Math.abs(diff) < 0.001) {
                        this.scale = this.targetScale;
                    } else {
                        // Frame-rate independent smoothing
                        const factor = 1 - Math.exp(-speed * dt * 3);
                        this.scale += diff * factor;
                    }
                }

                // Smooth zoom and opacity transitions (also frame-rate independent)
                const zoomFactor = 1 - Math.exp(-config.imageZoomSpeed * dt * 3);
                const opacityFactor = 1 - Math.exp(-config.opacityTransitionSpeed * dt * 3);

                const zoomDiff = this.targetZoom - this.zoom;
                if (Math.abs(zoomDiff) < 0.01) {
                    this.zoom = this.targetZoom;
                } else {
                    this.zoom += zoomDiff * zoomFactor;
                }

                const opacityDiff = this.targetOpacity - this.opacity;
                if (Math.abs(opacityDiff) < 0.01) {
                    this.opacity = this.targetOpacity;
                } else {
                    this.opacity += opacityDiff * opacityFactor;
                }
            }

            createPattern() {
                const size = 300;
                const patternCanvas = document.createElement('canvas');
                patternCanvas.width = size;
                patternCanvas.height = size;
                const pctx = patternCanvas.getContext('2d');

                // Gradient background
                const gradient = pctx.createLinearGradient(0, 0, size, size);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(1, this.adjustColor(this.color, -40));
                pctx.fillStyle = gradient;
                pctx.fillRect(0, 0, size, size);

                // Decorative circles
                pctx.globalAlpha = 0.08;
                for (let i = 0; i < 5; i++) {
                    const cx = Math.random() * size;
                    const cy = Math.random() * size;
                    const r = 30 + Math.random() * 60;
                    pctx.beginPath();
                    pctx.arc(cx, cy, r, 0, Math.PI * 2);
                    pctx.fillStyle = '#fff';
                    pctx.fill();
                }

                // Cell number
                pctx.globalAlpha = 0.2;
                pctx.fillStyle = '#fff';
                pctx.font = `bold ${size * 0.35}px system-ui, sans-serif`;
                pctx.textAlign = 'center';
                pctx.textBaseline = 'middle';
                pctx.fillText(this.index + 1, size / 2, size / 2);

                this.pattern = patternCanvas;
            }

            adjustColor(hex, amount) {
                const num = parseInt(hex.slice(1), 16);
                const r = Math.min(255, Math.max(0, (num >> 16) + amount));
                const g = Math.min(255, Math.max(0, ((num >> 8) & 0xff) + amount));
                const b = Math.min(255, Math.max(0, (num & 0xff) + amount));
                return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
            }
        }

        // ========== EDGE-BASED VORONOI PHYSICS ==========
        // Edges are the fundamental unit - they're shared between cells
        // When one cell expands, it pushes shared edges toward neighbors
        // Polygons are reconstructed from edge intersections

        let voronoiEdges = [];  // Array of edges between cells

        // Edge structure: { cellA, cellB, midX, midY, nx, ny, dist }
        // cellA, cellB: indices of adjacent cells (-1 for boundary)
        // midX, midY: base midpoint of the edge
        // nx, ny: unit normal pointing from cellB toward cellA
        // dist: distance between cell centers

        function computeBaseVoronoi() {
            const zoneTop = config.contentZoneEnabled ? height * config.contentZoneTop : 0;
            const zoneBottom = config.contentZoneEnabled ? height * (1 - config.contentZoneBottom) : height;
            const buffer = config.bleedBuffer;

            // First, compute standard Voronoi to get base polygons and find adjacencies
            const bounds = [
                [-buffer, zoneTop - buffer],
                [width + buffer, zoneTop - buffer],
                [width + buffer, zoneBottom + buffer],
                [-buffer, zoneBottom + buffer]
            ];

            // Build edges between all cell pairs
            voronoiEdges = [];

            for (let i = 0; i < cells.length; i++) {
                for (let j = i + 1; j < cells.length; j++) {
                    const cellA = cells[i];
                    const cellB = cells[j];

                    const dx = cellB.baseX - cellA.baseX;
                    const dy = cellB.baseY - cellA.baseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 0.001) continue;

                    // Edge midpoint and normal
                    const midX = (cellA.baseX + cellB.baseX) / 2;
                    const midY = (cellA.baseY + cellB.baseY) / 2;

                    // Normal points from B toward A (so positive shift benefits A)
                    const nx = -dx / dist;
                    const ny = -dy / dist;

                    voronoiEdges.push({
                        cellA: i,
                        cellB: j,
                        midX, midY,
                        nx, ny,
                        dist
                    });
                }
            }

            // Compute base polygons using standard Voronoi
            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                let polygon = bounds.map(p => [...p]);

                for (let j = 0; j < cells.length; j++) {
                    if (i === j) continue;
                    const other = cells[j];

                    const dx = other.baseX - cell.baseX;
                    const dy = other.baseY - cell.baseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 0.001) continue;

                    const midX = (cell.baseX + other.baseX) / 2;
                    const midY = (cell.baseY + other.baseY) / 2;
                    const nx = cell.baseX - other.baseX;
                    const ny = cell.baseY - other.baseY;

                    polygon = clipPolygon(polygon, midX, midY, nx, ny);
                    if (polygon.length < 3) break;
                }

                cell.basePolygon = polygon.length >= 3 ? polygon : null;
                cell.baseCentroid = getPolygonCentroid(cell.basePolygon);
            }

            updateDisplayPolygons();
        }

        // Rebuild polygons based on current edge positions (affected by cell scales)
        function updateDisplayPolygons() {
            const zoneTop = config.contentZoneEnabled ? height * config.contentZoneTop : 0;
            const zoneBottom = config.contentZoneEnabled ? height * (1 - config.contentZoneBottom) : height;
            const buffer = config.bleedBuffer;
            const gap = config.gap;

            // Compute edge shifts based on cell scales
            // displaceRatio controls how much edges move vs visual-only scaling
            const edgeShifts = voronoiEdges.map(edge => {
                const scaleA = cells[edge.cellA].scale;
                const scaleB = cells[edge.cellB].scale;

                // Weight difference determines edge shift
                // Positive = edge moves toward B (A gains territory)
                const weightDiff = scaleA - scaleB;

                // Push strength based on config
                const pushFactor = config.maxExpansion * config.displaceRatio * 0.5;
                let shift = weightDiff * pushFactor;

                // Clamp shift to prevent edges crossing cell centers
                const maxShift = edge.dist * 0.4;
                shift = Math.max(-maxShift, Math.min(maxShift, shift));

                return {
                    ...edge,
                    // Shifted edge position
                    shiftedMidX: edge.midX + edge.nx * shift,
                    shiftedMidY: edge.midY + edge.ny * shift,
                    shift
                };
            });

            // Bounds for clipping
            const bounds = [
                [-buffer, zoneTop - buffer],
                [width + buffer, zoneTop - buffer],
                [width + buffer, zoneBottom + buffer],
                [-buffer, zoneBottom + buffer]
            ];

            // Rebuild each cell's polygon using shifted edges
            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                let polygon = bounds.map(p => [...p]);

                // Clip against all shifted edges involving this cell
                for (const edge of edgeShifts) {
                    let isMyEdge = false;
                    let normalSign = 1;

                    if (edge.cellA === i) {
                        isMyEdge = true;
                        normalSign = 1;  // Normal points toward us
                    } else if (edge.cellB === i) {
                        isMyEdge = true;
                        normalSign = -1;  // Normal points away, flip it
                    }

                    if (!isMyEdge) continue;

                    // Clip polygon against this edge
                    const nx = edge.nx * normalSign;
                    const ny = edge.ny * normalSign;

                    polygon = clipPolygon(polygon, edge.shiftedMidX, edge.shiftedMidY, nx, ny);
                    if (polygon.length < 3) break;
                }

                if (polygon.length < 3) {
                    cell.polygon = cell.basePolygon;
                    cell.displayPolygon = cell.basePolygon;
                    continue;
                }

                // Store the physics polygon (for hit testing)
                cell.polygon = polygon;
                cell.baseCentroid = getPolygonCentroid(polygon);

                // Apply gap inset for display
                const inset = insetPolygon(polygon, gap / 2);

                // For expanding cells: extend into buffer zone by expanding clip bounds
                // NO centroid-based scaling - this keeps edge angles clean (no muffin top)
                // The cell's edges at the boundary naturally extend as bounds expand
                const scaleExtra = Math.max(0, cell.scale - 1.0);
                const bufferFraction = scaleExtra / (config.maxExpansion / 300);
                const smoothBuffer = buffer * Math.min(1, bufferFraction);

                // Expanded bounds for hovered cell
                const clipTop = zoneTop - smoothBuffer;
                const clipBottom = zoneBottom + smoothBuffer;
                const clipLeft = -smoothBuffer;
                const clipRight = width + smoothBuffer;

                cell.displayPolygon = clipToRect(inset, clipLeft, clipTop, clipRight, clipBottom);
            }
        }

        function clipPolygon(polygon, px, py, nx, ny) {
            const output = [];
            const n = polygon.length;

            for (let i = 0; i < n; i++) {
                const curr = polygon[i];
                const next = polygon[(i + 1) % n];

                const currDist = (curr[0] - px) * nx + (curr[1] - py) * ny;
                const nextDist = (next[0] - px) * nx + (next[1] - py) * ny;

                if (currDist >= 0) {
                    output.push(curr);
                    if (nextDist < 0) {
                        output.push(lineIntersect(curr, next, px, py, nx, ny));
                    }
                } else if (nextDist >= 0) {
                    output.push(lineIntersect(curr, next, px, py, nx, ny));
                }
            }

            return output;
        }

        function lineIntersect(a, b, px, py, nx, ny) {
            const dx = b[0] - a[0];
            const dy = b[1] - a[1];
            const denom = dx * nx + dy * ny;
            if (Math.abs(denom) < 0.0001) return [...a];
            const t = ((px - a[0]) * nx + (py - a[1]) * ny) / denom;
            return [a[0] + t * dx, a[1] + t * dy];
        }

        function getPolygonCentroid(polygon) {
            if (!polygon || polygon.length < 3) return { x: 0, y: 0 };
            let cx = 0, cy = 0;
            for (const p of polygon) {
                cx += p[0];
                cy += p[1];
            }
            return { x: cx / polygon.length, y: cy / polygon.length };
        }

        // Proper polygon inset - offset each edge inward by amount, then find new vertices
        // This creates uniform gaps between adjacent cells
        function insetPolygon(polygon, amount) {
            if (!polygon || polygon.length < 3 || amount <= 0) return polygon;

            const n = polygon.length;

            // Compute signed area to determine winding direction
            let signedArea = 0;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                signedArea += polygon[i][0] * polygon[j][1];
                signedArea -= polygon[j][0] * polygon[i][1];
            }
            // signedArea > 0 means CCW, < 0 means CW (in screen coords where Y increases downward)
            const windingSign = signedArea > 0 ? 1 : -1;

            const insetEdges = [];

            // For each edge, compute the inward-offset line
            for (let i = 0; i < n; i++) {
                const p1 = polygon[i];
                const p2 = polygon[(i + 1) % n];

                // Edge direction
                const edx = p2[0] - p1[0];
                const edy = p2[1] - p1[1];
                const len = Math.sqrt(edx * edx + edy * edy);

                if (len < 0.001) continue;

                // Inward normal - perpendicular to edge, direction depends on winding
                // For CCW: inward is to the right of edge direction (dy, -dx)
                // For CW: inward is to the left of edge direction (-dy, dx)
                const nx = windingSign * edy / len;
                const ny = windingSign * -edx / len;

                // Offset the edge inward
                const offsetP1 = [p1[0] + nx * amount, p1[1] + ny * amount];
                const offsetP2 = [p2[0] + nx * amount, p2[1] + ny * amount];

                insetEdges.push({ p1: offsetP1, p2: offsetP2, nx, ny });
            }

            if (insetEdges.length < 3) return polygon;

            // Compute new vertices as intersections of consecutive offset edges
            const result = [];
            for (let i = 0; i < insetEdges.length; i++) {
                const e1 = insetEdges[i];
                const e2 = insetEdges[(i + 1) % insetEdges.length];

                // Find intersection of two lines
                const intersection = lineLineIntersect(e1.p1, e1.p2, e2.p1, e2.p2);
                if (intersection) {
                    result.push(intersection);
                }
            }

            // Validate result - check if polygon collapsed or inverted
            if (result.length < 3) return polygon;

            // Check that result area is smaller than original (sanity check)
            let resultArea = 0;
            for (let i = 0; i < result.length; i++) {
                const j = (i + 1) % result.length;
                resultArea += result[i][0] * result[j][1];
                resultArea -= result[j][0] * result[i][1];
            }
            resultArea = Math.abs(resultArea);
            const origArea = Math.abs(signedArea);

            // If result is larger than original, something went wrong
            if (resultArea > origArea || resultArea < 100) return polygon;

            return result;
        }

        // Line-line intersection helper
        function lineLineIntersect(p1, p2, p3, p4) {
            const x1 = p1[0], y1 = p1[1];
            const x2 = p2[0], y2 = p2[1];
            const x3 = p3[0], y3 = p3[1];
            const x4 = p4[0], y4 = p4[1];

            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 0.0001) {
                // Lines are parallel, return midpoint of shared region
                return [(p2[0] + p3[0]) / 2, (p2[1] + p3[1]) / 2];
            }

            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            return [x1 + t * (x2 - x1), y1 + t * (y2 - y1)];
        }

        // Simple rect clipping
        function clipToRect(polygon, left, top, right, bottom) {
            if (!polygon || polygon.length < 3) return polygon;

            let result = polygon;
            result = clipPolygon(result, left, top, 1, 0);      // left
            result = clipPolygon(result, right, top, -1, 0);    // right
            result = clipPolygon(result, left, top, 0, 1);      // top
            result = clipPolygon(result, left, bottom, 0, -1);  // bottom

            return result;
        }

        // ========== POLYGON SIMPLIFICATION ==========
        // Removes nearly-collinear vertices and merges close points
        // This helps corner rounding work better on clipped polygons
        // More aggressive simplification: larger minEdgeLength, stricter collinearity
        function simplifyPolygon(polygon, minEdgeLength = 20, collinearThreshold = 0.95) {
            if (!polygon || polygon.length < 3) return polygon;

            // First pass: merge vertices that are too close together
            let simplified = [];
            for (let i = 0; i < polygon.length; i++) {
                const curr = polygon[i];
                const last = simplified[simplified.length - 1];

                if (!last) {
                    simplified.push(curr);
                    continue;
                }

                const dist = Math.sqrt((curr[0] - last[0]) ** 2 + (curr[1] - last[1]) ** 2);
                if (dist >= minEdgeLength) {
                    simplified.push(curr);
                } else {
                    // Merge: keep the midpoint
                    simplified[simplified.length - 1] = [(curr[0] + last[0]) / 2, (curr[1] + last[1]) / 2];
                }
            }

            // Check first and last vertex distance
            if (simplified.length > 2) {
                const first = simplified[0];
                const last = simplified[simplified.length - 1];
                const dist = Math.sqrt((first[0] - last[0]) ** 2 + (first[1] - last[1]) ** 2);
                if (dist < minEdgeLength) {
                    simplified[0] = [(first[0] + last[0]) / 2, (first[1] + last[1]) / 2];
                    simplified.pop();
                }
            }

            if (simplified.length < 3) return polygon;

            // Second pass: remove nearly-collinear points
            const result = [];
            const n = simplified.length;

            for (let i = 0; i < n; i++) {
                const prev = simplified[(i - 1 + n) % n];
                const curr = simplified[i];
                const next = simplified[(i + 1) % n];

                // Calculate vectors
                const v1x = curr[0] - prev[0];
                const v1y = curr[1] - prev[1];
                const v2x = next[0] - curr[0];
                const v2y = next[1] - curr[1];

                const len1 = Math.sqrt(v1x * v1x + v1y * v1y);
                const len2 = Math.sqrt(v2x * v2x + v2y * v2y);

                if (len1 < 0.001 || len2 < 0.001) {
                    continue; // Skip degenerate edges
                }

                // Dot product of normalized vectors
                const dot = (v1x * v2x + v1y * v2y) / (len1 * len2);

                // If vectors are nearly parallel (dot close to 1), skip this vertex
                if (dot < collinearThreshold) {
                    result.push(curr);
                }
            }

            return result.length >= 3 ? result : polygon;
        }

        // ========== ROUNDED CORNERS ==========
        function drawRoundedPolygon(ctx, polygon, radius) {
            if (!polygon || polygon.length < 3) return;

            // Calculate polygon area to detect degenerate cases
            let area = 0;
            for (let i = 0; i < polygon.length; i++) {
                const j = (i + 1) % polygon.length;
                area += polygon[i][0] * polygon[j][1];
                area -= polygon[j][0] * polygon[i][1];
            }
            area = Math.abs(area) / 2;

            // If polygon is too small, just draw it without rounding
            if (area < 100 || radius <= 0) {
                ctx.beginPath();
                ctx.moveTo(polygon[0][0], polygon[0][1]);
                for (let i = 1; i < polygon.length; i++) {
                    ctx.lineTo(polygon[i][0], polygon[i][1]);
                }
                ctx.closePath();
                return;
            }

            const n = polygon.length;

            // Pre-calculate all corner radii to ensure consistency
            const radii = [];
            for (let i = 0; i < n; i++) {
                const prev = polygon[(i - 1 + n) % n];
                const curr = polygon[i];
                const next = polygon[(i + 1) % n];

                const dist1 = Math.sqrt((prev[0] - curr[0]) ** 2 + (prev[1] - curr[1]) ** 2);
                const dist2 = Math.sqrt((next[0] - curr[0]) ** 2 + (next[1] - curr[1]) ** 2);

                // Limit radius to 50% of the shorter edge - allows corners to meet at edge midpoints
                // arcTo() handles overflow gracefully, so this is safe even for tight corners
                const maxRadius = Math.min(dist1, dist2) * 0.5;
                radii[i] = Math.max(0, Math.min(radius, maxRadius));
            }

            ctx.beginPath();

            // Find first valid starting point
            let started = false;
            for (let i = 0; i < n; i++) {
                const prev = polygon[(i - 1 + n) % n];
                const curr = polygon[i];
                const next = polygon[(i + 1) % n];
                const r = radii[i];

                let dx1 = prev[0] - curr[0];
                let dy1 = prev[1] - curr[1];
                let dx2 = next[0] - curr[0];
                let dy2 = next[1] - curr[1];

                const dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

                if (r < 0.5 || dist1 < 0.5 || dist2 < 0.5) {
                    // Sharp corner - no rounding
                    if (!started) {
                        ctx.moveTo(curr[0], curr[1]);
                        started = true;
                    } else {
                        ctx.lineTo(curr[0], curr[1]);
                    }
                } else {
                    // Normalize
                    dx1 /= dist1; dy1 /= dist1;
                    dx2 /= dist2; dy2 /= dist2;

                    // Points where the arc starts and ends
                    const startX = curr[0] + dx1 * r;
                    const startY = curr[1] + dy1 * r;
                    const endX = curr[0] + dx2 * r;
                    const endY = curr[1] + dy2 * r;

                    if (!started) {
                        ctx.moveTo(startX, startY);
                        started = true;
                    } else {
                        ctx.lineTo(startX, startY);
                    }

                    // Draw arc using arcTo
                    ctx.arcTo(curr[0], curr[1], endX, endY, r);
                }
            }

            ctx.closePath();
        }

        // ========== INITIALIZATION ==========
        function init() {
            canvas = document.getElementById('voronoiCanvas');
            ctx = canvas.getContext('2d');
            tooltip = document.getElementById('tooltip');

            resize();
            generateCells();
            setupEvents();
            animate(0);
        }

        function resize() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;

            width = rect.width;
            height = rect.height;

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            if (cells.length > 0) {
                generateCells();
            }
        }

        function generateCells() {
            cells = [];
            const margin = 80;

            // Calculate vertical bounds based on content zone
            let yMin, yMax;
            const zoneTop = height * config.contentZoneTop;
            const zoneBottom = height * (1 - config.contentZoneBottom);

            if (config.contentZoneEnabled) {
                yMin = zoneTop + margin / 2;
                yMax = zoneBottom - margin / 2;
                // Ensure valid range
                if (yMax <= yMin) {
                    yMin = margin;
                    yMax = height - margin;
                }
            } else {
                yMin = margin;
                yMax = height - margin;
            }

            const contentHeight = yMax - yMin;
            const minDist = Math.sqrt((width * contentHeight) / config.cellCount) * 0.6;

            const points = [];
            let attempts = 0;

            // Generate visible cell positions
            while (points.length < config.cellCount && attempts < 2000) {
                const x = margin + Math.random() * (width - 2 * margin);
                const y = yMin + Math.random() * (yMax - yMin);

                let valid = true;
                for (const p of points) {
                    const dx = p[0] - x, dy = p[1] - y;
                    if (dx * dx + dy * dy < minDist * minDist * 0.5) {
                        valid = false;
                        break;
                    }
                }

                if (valid) points.push([x, y]);
                attempts++;
            }

            while (points.length < config.cellCount) {
                points.push([
                    margin + Math.random() * (width - 2 * margin),
                    yMin + Math.random() * (yMax - yMin)
                ]);
            }

            // Create visible cells
            for (let i = 0; i < points.length; i++) {
                const cell = new Cell(points[i][0], points[i][1], i);
                cell.createPattern();
                cells.push(cell);
            }

            // Compute base Voronoi ONCE - shapes are fixed from here
            computeBaseVoronoi();
            updateDisplayPolygons();
        }

        // ========== EVENTS ==========
        function setupEvents() {
            window.addEventListener('resize', () => {
                resize();
                // Recompute base Voronoi on resize
                computeBaseVoronoi();
                updateDisplayPolygons();
            });

            canvas.addEventListener('mousemove', handlePointerMove);
            canvas.addEventListener('mouseleave', handlePointerLeave);
            canvas.addEventListener('click', handleClick);

            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);

            setupControls();
        }

        function handlePointerMove(e) {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            updateHover();
            updateTooltip(e.clientX, e.clientY);
        }

        function handlePointerLeave() {
            mouseX = -9999;
            mouseY = -9999;
            hoveredCell = -1;
            cells.forEach(c => {
                c.targetZoom = config.nonHoverImageZoom;
                c.targetOpacity = config.nonHoveredOpacity;
            });
            tooltip.classList.remove('visible');
        }

        function handleClick() {
            if (hoveredCell >= 0 && cells[hoveredCell]) {
                const cell = cells[hoveredCell];
                if (cell.link) {
                    console.log('Navigate to:', cell.link);
                }
            }
        }

        let touchStartCell = -1;
        let touchStartTime = 0;

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            updateHover();
            touchStartCell = hoveredCell;
            touchStartTime = Date.now();
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            updateHover();
        }

        function handleTouchEnd() {
            if (Date.now() - touchStartTime < 300 && touchStartCell === hoveredCell && hoveredCell >= 0) {
                handleClick();
            }
            setTimeout(() => {
                mouseX = -9999;
                mouseY = -9999;
                hoveredCell = -1;
                cells.forEach(c => {
                    c.targetZoom = config.nonHoverImageZoom;
                    c.targetOpacity = config.nonHoveredOpacity;
                });
            }, 100);
        }

        function updateHover() {
            let found = -1;

            for (let i = 0; i < cells.length; i++) {
                if (cells[i].polygon && pointInPolygon(mouseX, mouseY, cells[i].polygon)) {
                    found = i;
                    break;
                }
            }

            if (found !== hoveredCell) {
                if (hoveredCell >= 0) {
                    cells[hoveredCell].targetZoom = config.nonHoverImageZoom;
                    cells[hoveredCell].targetOpacity = config.nonHoveredOpacity;
                }
                hoveredCell = found;
                if (hoveredCell >= 0) {
                    cells[hoveredCell].targetZoom = 1.0;
                    cells[hoveredCell].targetOpacity = 1.0;
                }
            }

            canvas.style.cursor = hoveredCell >= 0 ? 'pointer' : 'default';
        }

        function pointInPolygon(x, y, polygon) {
            if (!polygon || polygon.length < 3) return false;

            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];

                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function updateTooltip(clientX, clientY) {
            if (hoveredCell >= 0 && cells[hoveredCell]) {
                const cell = cells[hoveredCell];
                tooltip.textContent = cell.title;
                tooltip.classList.add('visible');

                const rect = canvas.parentElement.getBoundingClientRect();
                const cursorX = clientX - rect.left;
                const cursorY = clientY - rect.top;

                // Direction from cell center to cursor
                const dx = cursorX - cell.x;
                const dy = cursorY - cell.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Position tooltip on opposite side of cursor from cell center
                // (in the "shadow" cast by cursor, away from the cell center "sun")
                const offset = 50;
                let tooltipX, tooltipY;

                if (dist > 1) {
                    // Normalize and extend in same direction (away from center)
                    tooltipX = cursorX + (dx / dist) * offset;
                    tooltipY = cursorY + (dy / dist) * offset;
                } else {
                    tooltipX = cursorX + offset;
                    tooltipY = cursorY;
                }

                // Get tooltip dimensions for boundary checking
                const tooltipRect = tooltip.getBoundingClientRect();
                const tw = tooltipRect.width || 100;
                const th = tooltipRect.height || 30;

                // Keep tooltip in bounds
                tooltipX = Math.max(5, Math.min(width - tw - 5, tooltipX));
                tooltipY = Math.max(5, Math.min(height - th - 5, tooltipY));

                tooltip.style.left = tooltipX + 'px';
                tooltip.style.top = tooltipY + 'px';
            } else {
                tooltip.classList.remove('visible');
            }
        }

        function setupControls() {
            // Cell count
            const cellCountEl = document.getElementById('cellCount');
            const cellCountVal = document.getElementById('cellCountVal');
            cellCountEl.addEventListener('input', () => {
                config.cellCount = +cellCountEl.value;
                cellCountVal.textContent = config.cellCount;
            });
            cellCountEl.addEventListener('change', generateCells);

            // Gap
            const gapEl = document.getElementById('gap');
            const gapVal = document.getElementById('gapVal');
            gapEl.addEventListener('input', () => {
                config.gap = +gapEl.value;
                gapVal.textContent = config.gap;
                // Gap is applied in updateDisplayPolygons() every frame
            });

            // Corner radius
            const cornerEl = document.getElementById('cornerRadius');
            const cornerVal = document.getElementById('cornerRadiusVal');
            cornerEl.addEventListener('input', () => {
                config.cornerRadius = +cornerEl.value;
                cornerVal.textContent = config.cornerRadius;
            });

            // Max Expansion (inflation)
            const maxExpansionEl = document.getElementById('maxExpansion');
            const maxExpansionVal = document.getElementById('maxExpansionVal');
            maxExpansionEl.addEventListener('input', () => {
                config.maxExpansion = +maxExpansionEl.value;
                maxExpansionVal.textContent = config.maxExpansion;
            });

            // Expansion Speed - linear with much smaller range for fine control
            // 0 = 0 (inert), 100 = 0.05 (fast but not instant)
            const expansionSpeedEl = document.getElementById('expansionSpeed');
            const expansionSpeedVal = document.getElementById('expansionSpeedVal');
            expansionSpeedEl.addEventListener('input', () => {
                // Linear: 0-100 maps to 0-0.05
                config.expansionSpeed = +expansionSpeedEl.value / 2000;
                expansionSpeedVal.textContent = config.expansionSpeed.toFixed(3);
            });

            // Displace Ratio - 0 = pure shrink, 1 = pure displace
            const displaceRatioEl = document.getElementById('displaceRatio');
            const displaceRatioVal = document.getElementById('displaceRatioVal');
            displaceRatioEl.addEventListener('input', () => {
                config.displaceRatio = +displaceRatioEl.value / 100;
                displaceRatioVal.textContent = config.displaceRatio.toFixed(2);
            });

            // Non-Hovered Opacity
            const nonHoveredOpacityEl = document.getElementById('nonHoveredOpacity');
            const nonHoveredOpacityVal = document.getElementById('nonHoveredOpacityVal');
            nonHoveredOpacityEl.addEventListener('input', () => {
                config.nonHoveredOpacity = +nonHoveredOpacityEl.value / 100;
                nonHoveredOpacityVal.textContent = config.nonHoveredOpacity.toFixed(2);
                cells.forEach((c, i) => {
                    if (i !== hoveredCell) {
                        c.targetOpacity = config.nonHoveredOpacity;
                    }
                });
            });

            // Non-Hover Image Zoom
            const nonHoverImageZoomEl = document.getElementById('nonHoverImageZoom');
            const nonHoverImageZoomVal = document.getElementById('nonHoverImageZoomVal');
            nonHoverImageZoomEl.addEventListener('input', () => {
                config.nonHoverImageZoom = +nonHoverImageZoomEl.value / 10;
                nonHoverImageZoomVal.textContent = config.nonHoverImageZoom.toFixed(1);
                cells.forEach((c, i) => {
                    if (i !== hoveredCell) {
                        c.targetZoom = config.nonHoverImageZoom;
                    }
                });
            });

            // Content Zone Controls
            const contentZoneTopEl = document.getElementById('contentZoneTop');
            const contentZoneTopVal = document.getElementById('contentZoneTopVal');
            contentZoneTopEl.addEventListener('input', () => {
                config.contentZoneTop = +contentZoneTopEl.value / 100;
                contentZoneTopVal.textContent = contentZoneTopEl.value + '%';
            });
            contentZoneTopEl.addEventListener('change', generateCells);

            const contentZoneBottomEl = document.getElementById('contentZoneBottom');
            const contentZoneBottomVal = document.getElementById('contentZoneBottomVal');
            contentZoneBottomEl.addEventListener('input', () => {
                config.contentZoneBottom = +contentZoneBottomEl.value / 100;
                contentZoneBottomVal.textContent = contentZoneBottomEl.value + '%';
            });
            contentZoneBottomEl.addEventListener('change', generateCells);

            const bleedBufferEl = document.getElementById('bleedBuffer');
            const bleedBufferVal = document.getElementById('bleedBufferVal');
            bleedBufferEl.addEventListener('input', () => {
                config.bleedBuffer = +bleedBufferEl.value;
                bleedBufferVal.textContent = config.bleedBuffer;
                // Buffer affects base Voronoi bounds - need to recompute
                computeBaseVoronoi();
            });

            // Buttons
            document.getElementById('regenerate').addEventListener('click', generateCells);

            const toggleContentZone = document.getElementById('toggleContentZone');
            toggleContentZone.classList.toggle('active', config.contentZoneEnabled);
            toggleContentZone.addEventListener('click', () => {
                config.contentZoneEnabled = !config.contentZoneEnabled;
                toggleContentZone.classList.toggle('active', config.contentZoneEnabled);
                generateCells();
            });

            const toggleDebug = document.getElementById('toggleDebug');
            toggleDebug.addEventListener('click', () => {
                config.debugMode = !config.debugMode;
                toggleDebug.classList.toggle('active', config.debugMode);
            });

            const loadUnsplash = document.getElementById('loadUnsplash');
            loadUnsplash.addEventListener('click', loadUnsplashImages);
        }

        // ========== UNSPLASH IMAGES ==========
        function loadUnsplashImages() {
            const btn = document.getElementById('loadUnsplash');
            btn.textContent = 'Loading...';
            btn.disabled = true;

            let loaded = 0;
            const total = cells.length;

            cells.forEach((cell, i) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                // Use random seed for variety, sig for cache busting
                img.src = `https://picsum.photos/300/300?random=${i}&t=${Date.now()}`;

                img.onload = () => {
                    const size = 300;
                    const patternCanvas = document.createElement('canvas');
                    patternCanvas.width = size;
                    patternCanvas.height = size;
                    const pctx = patternCanvas.getContext('2d');

                    // Draw image covering the canvas
                    pctx.drawImage(img, 0, 0, size, size);

                    cell.pattern = patternCanvas;
                    loaded++;

                    if (loaded >= total) {
                        btn.textContent = 'Unsplash';
                        btn.disabled = false;
                    }
                };

                img.onerror = () => {
                    loaded++;
                    if (loaded >= total) {
                        btn.textContent = 'Unsplash';
                        btn.disabled = false;
                    }
                };
            });
        }

        // ========== PHYSICS ==========
        function updatePhysics(dt) {
            // Simple: hovered cell scales up, others stay at 1.0
            // Scale factor: 1.0 = normal, 1.0 + maxExpansion/300 = expanded
            const expandedScale = 1.0 + config.maxExpansion / 300;

            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                cell.targetScale = (i === hoveredCell) ? expandedScale : 1.0;
                cell.update(dt, i === hoveredCell);
            }

            // Update display polygons (just scaling, no Voronoi recompute)
            updateDisplayPolygons();
        }

        // ========== RENDERING ==========
        function render() {
            ctx.clearRect(0, 0, width, height);

            // Helper to draw a single cell
            function drawCell(i) {
                const cell = cells[i];
                const polygon = cell.displayPolygon;

                if (!polygon || polygon.length < 3) return;

                ctx.save();

                // Apply opacity
                ctx.globalAlpha = cell.opacity;

                // Create rounded clipping path
                drawRoundedPolygon(ctx, polygon, config.cornerRadius);
                ctx.clip();

                // Calculate bounds
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const p of polygon) {
                    minX = Math.min(minX, p[0]);
                    maxX = Math.max(maxX, p[0]);
                    minY = Math.min(minY, p[1]);
                    maxY = Math.max(maxY, p[1]);
                }

                const cellW = maxX - minX;
                const cellH = maxY - minY;
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                // Draw pattern with zoom
                if (cell.pattern) {
                    const zoom = cell.zoom;
                    const size = Math.max(cellW, cellH) * 1.4 * zoom;
                    ctx.drawImage(
                        cell.pattern,
                        centerX - size / 2,
                        centerY - size / 2,
                        size,
                        size
                    );
                }

                ctx.restore();

                // Draw border
                drawRoundedPolygon(ctx, polygon, config.cornerRadius);

                if (i === hoveredCell) {
                    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'rgba(255,255,255,0.5)';
                    ctx.shadowBlur = 15;
                } else {
                    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                    ctx.lineWidth = 1;
                    ctx.shadowBlur = 0;
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Draw non-hovered cells first
            for (let i = 0; i < cells.length; i++) {
                if (i !== hoveredCell) {
                    drawCell(i);
                }
            }

            // Draw hovered cell LAST (on top) so it can overlap neighbors
            if (hoveredCell >= 0 && hoveredCell < cells.length) {
                drawCell(hoveredCell);
            }

            // No mask - cells themselves define the boundary
            // Non-hovered cells are clipped to soft bounds
            // Hovered cell extends into buffer - what you see is what you get

            // Debug mode
            if (config.debugMode) {
                if (config.contentZoneEnabled) {
                    const zoneTop = height * config.contentZoneTop;
                    const zoneBottom = height * (1 - config.contentZoneBottom);
                    const buffer = config.bleedBuffer;
                    const hardTop = zoneTop - buffer;
                    const hardBottom = zoneBottom + buffer;

                    // Fill the margin areas with visible debug color
                    ctx.fillStyle = 'rgba(80, 40, 100, 0.5)'; // Purple tint for margin areas
                    ctx.fillRect(0, 0, width, hardTop);
                    ctx.fillRect(0, hardBottom, width, height - hardBottom);

                    // Fill the buffer zone with different color
                    ctx.fillStyle = 'rgba(100, 60, 40, 0.4)'; // Brown tint for buffer zone
                    ctx.fillRect(0, hardTop, width, zoneTop - hardTop);
                    ctx.fillRect(0, zoneBottom, width, hardBottom - zoneBottom);

                    // SOLID LINE = Hard container (buffer edge - absolute limit)
                    ctx.strokeStyle = 'rgba(255, 150, 50, 1)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(0, hardTop);
                    ctx.lineTo(width, hardTop);
                    ctx.moveTo(0, hardBottom);
                    ctx.lineTo(width, hardBottom);
                    ctx.stroke();

                    // DASHED LINE = Soft container (content zone - where cells should stay)
                    ctx.strokeStyle = 'rgba(100, 255, 100, 1)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 4]);
                    ctx.beginPath();
                    ctx.moveTo(0, zoneTop);
                    ctx.lineTo(width, zoneTop);
                    ctx.moveTo(0, zoneBottom);
                    ctx.lineTo(width, zoneBottom);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Label the zones
                    ctx.font = '12px monospace';
                    ctx.fillStyle = 'rgba(255, 150, 50, 1)';
                    ctx.fillText('HARD (buffer edge)', 10, hardTop + 15);
                    ctx.fillStyle = 'rgba(100, 255, 100, 1)';
                    ctx.fillText('SOFT (content zone)', 10, zoneTop + 15);
                    ctx.fillStyle = 'rgba(180, 120, 80, 1)';
                    ctx.fillText('BUFFER ZONE', 10, (hardTop + zoneTop) / 2 + 5);
                }

                // Draw cell debug info
                for (const cell of cells) {
                    const polygon = cell.displayPolygon;
                    const centroid = cell.baseCentroid || { x: cell.baseX, y: cell.baseY };

                    // Draw lines from each corner to cell center
                    if (polygon && polygon.length >= 3) {
                        ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([3, 3]);
                        for (const corner of polygon) {
                            ctx.beginPath();
                            ctx.moveTo(corner[0], corner[1]);
                            ctx.lineTo(centroid.x, centroid.y);
                            ctx.stroke();
                        }
                        ctx.setLineDash([]);

                        // Draw corner dots
                        ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
                        for (const corner of polygon) {
                            ctx.beginPath();
                            ctx.arc(corner[0], corner[1], 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Cell center (white dot, size indicates scale)
                    const dotSize = 4 + (cell.scale - 1) * 20;
                    ctx.fillStyle = cell.scale > 1.01 ? 'rgba(255,200,100,0.9)' : '#fff';
                    ctx.beginPath();
                    ctx.arc(centroid.x, centroid.y, dotSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // ========== ANIMATION LOOP ==========
        function animate(time) {
            const dt = Math.min((time - lastTime) / 16, 3);
            lastTime = time;

            updatePhysics(dt);
            render();

            animationId = requestAnimationFrame(animate);
        }

        // ========== START ==========
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    })();
    </script>
</body>
</html>
