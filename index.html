<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Voronoi Grid</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        .canvas-wrapper {
            flex: 1;
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            background: #111;
        }

        #voronoiCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .controls {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 140px;
        }

        .control-group label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4a9eff;
            cursor: pointer;
        }

        .control-value {
            font-size: 13px;
            color: #fff;
            font-weight: 500;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #4a9eff;
            color: #fff;
        }

        .btn-primary:hover {
            background: #3a8eef;
        }

        .btn-secondary {
            background: #333;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #444;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
                gap: 10px;
            }
            .controls {
                padding: 15px;
                gap: 15px;
            }
            .control-group {
                min-width: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-wrapper">
            <canvas id="voronoiCanvas"></canvas>
        </div>
        <div class="controls">
            <div class="control-group">
                <label>Cells</label>
                <input type="range" id="cellCount" min="5" max="50" value="12">
                <span class="control-value" id="cellCountValue">12</span>
            </div>
            <button class="btn btn-primary" id="regenerate">Regenerate</button>
            <button class="btn btn-secondary" id="toggleMode">Show Colors</button>
        </div>
    </div>

    <script>
    /*!
     * Delaunator - Fast Delaunay triangulation library
     * https://github.com/mapbox/delaunator
     * ISC License
     */
    const EPSILON = Math.pow(2, -52);
    const EDGE_STACK = new Uint32Array(512);

    class Delaunator {
        static from(points, getX = defaultGetX, getY = defaultGetY) {
            const n = points.length;
            const coords = new Float64Array(n * 2);
            for (let i = 0; i < n; i++) {
                coords[2 * i] = getX(points[i]);
                coords[2 * i + 1] = getY(points[i]);
            }
            return new Delaunator(coords);
        }

        constructor(coords) {
            const n = coords.length >> 1;
            if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

            this.coords = coords;
            const maxTriangles = Math.max(2 * n - 5, 0);
            this._triangles = new Uint32Array(maxTriangles * 3);
            this._halfedges = new Int32Array(maxTriangles * 3);
            this._hashSize = Math.ceil(Math.sqrt(n));
            this._hullPrev = new Uint32Array(n);
            this._hullNext = new Uint32Array(n);
            this._hullTri = new Uint32Array(n);
            this._hullHash = new Int32Array(this._hashSize).fill(-1);
            this._ids = new Uint32Array(n);
            this._dists = new Float64Array(n);

            this.update();
        }

        update() {
            const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} = this;
            const n = coords.length >> 1;

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            for (let i = 0; i < n; i++) {
                const x = coords[2 * i], y = coords[2 * i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                this._ids[i] = i;
            }
            const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;

            let i0, i1, i2;
            let minDist = Infinity;
            for (let i = 0; i < n; i++) {
                const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist) { i0 = i; minDist = d; }
            }
            const i0x = coords[2 * i0], i0y = coords[2 * i0 + 1];

            minDist = Infinity;
            for (let i = 0; i < n; i++) {
                if (i === i0) continue;
                const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist && d > 0) { i1 = i; minDist = d; }
            }
            let i1x = coords[2 * i1], i1y = coords[2 * i1 + 1];

            let minRadius = Infinity;
            for (let i = 0; i < n; i++) {
                if (i === i0 || i === i1) continue;
                const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
                if (r < minRadius) { i2 = i; minRadius = r; }
            }
            let i2x = coords[2 * i2], i2y = coords[2 * i2 + 1];

            if (minRadius === Infinity) {
                for (let i = 0; i < n; i++) {
                    this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
                }
                quicksort(this._ids, this._dists, 0, n - 1);
                const hull = new Uint32Array(n);
                let j = 0;
                for (let i = 0, d0 = -Infinity; i < n; i++) {
                    const id = this._ids[i];
                    if (this._dists[id] > d0) { hull[j++] = id; d0 = this._dists[id]; }
                }
                this.hull = hull.subarray(0, j);
                this.triangles = new Uint32Array(0);
                this.halfedges = new Uint32Array(0);
                return;
            }

            if (orient(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
                const i = i1, x = i1x, y = i1y;
                i1 = i2; i1x = i2x; i1y = i2y;
                i2 = i; i2x = x; i2y = y;
            }

            const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
            this._cx = center.x; this._cy = center.y;

            for (let i = 0; i < n; i++) {
                this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
            }
            quicksort(this._ids, this._dists, 0, n - 1);

            this._hullStart = i0;
            let hullSize = 3;

            hullNext[i0] = hullPrev[i2] = i1;
            hullNext[i1] = hullPrev[i0] = i2;
            hullNext[i2] = hullPrev[i1] = i0;

            hullTri[i0] = 0; hullTri[i1] = 1; hullTri[i2] = 2;

            hullHash.fill(-1);
            hullHash[this._hashKey(i0x, i0y)] = i0;
            hullHash[this._hashKey(i1x, i1y)] = i1;
            hullHash[this._hashKey(i2x, i2y)] = i2;

            this.trianglesLen = 0;
            this._addTriangle(i0, i1, i2, -1, -1, -1);

            for (let k = 0, xp, yp; k < this._ids.length; k++) {
                const i = this._ids[k];
                const x = coords[2 * i], y = coords[2 * i + 1];
                if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
                xp = x; yp = y;
                if (i === i0 || i === i1 || i === i2) continue;

                let start = 0;
                for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                    start = hullHash[(key + j) % this._hashSize];
                    if (start !== -1 && start !== hullNext[start]) break;
                }

                start = hullPrev[start];
                let e = start, q;
                while (q = hullNext[e], orient(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
                    e = q;
                    if (e === start) { e = -1; break; }
                }
                if (e === -1) continue;

                let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
                hullTri[i] = this._legalize(t + 2);
                hullTri[e] = t;
                hullSize++;

                let n = hullNext[e];
                while (q = hullNext[n], orient(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
                    t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                    hullTri[i] = this._legalize(t + 2);
                    hullNext[n] = n;
                    hullSize--;
                    n = q;
                }

                if (e === start) {
                    while (q = hullPrev[e], orient(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
                        t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                        this._legalize(t + 2);
                        hullTri[q] = t;
                        hullNext[e] = e;
                        hullSize--;
                        e = q;
                    }
                }

                this._hullStart = hullPrev[i] = e;
                hullNext[e] = hullPrev[n] = i;
                hullNext[i] = n;

                hullHash[this._hashKey(x, y)] = i;
                hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
            }

            this.hull = new Uint32Array(hullSize);
            for (let i = 0, e = this._hullStart; i < hullSize; i++) {
                this.hull[i] = e;
                e = hullNext[e];
            }

            this.triangles = this._triangles.subarray(0, this.trianglesLen);
            this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
        }

        _hashKey(x, y) {
            return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
        }

        _legalize(a) {
            const {_triangles: triangles, _halfedges: halfedges, coords} = this;
            let i = 0, ar = 0;

            while (true) {
                const b = halfedges[a];
                const a0 = a - a % 3;
                ar = a0 + (a + 2) % 3;

                if (b === -1) {
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                    continue;
                }

                const b0 = b - b % 3;
                const al = a0 + (a + 1) % 3;
                const bl = b0 + (b + 2) % 3;

                const p0 = triangles[ar];
                const pr = triangles[a];
                const pl = triangles[al];
                const p1 = triangles[bl];

                const illegal = inCircle(
                    coords[2 * p0], coords[2 * p0 + 1],
                    coords[2 * pr], coords[2 * pr + 1],
                    coords[2 * pl], coords[2 * pl + 1],
                    coords[2 * p1], coords[2 * p1 + 1]);

                if (illegal) {
                    triangles[a] = p1;
                    triangles[b] = p0;

                    const hbl = halfedges[bl];
                    if (hbl === -1) {
                        let e = this._hullStart;
                        do {
                            if (this._hullTri[e] === bl) {
                                this._hullTri[e] = a;
                                break;
                            }
                            e = this._hullPrev[e];
                        } while (e !== this._hullStart);
                    }
                    this._link(a, hbl);
                    this._link(b, halfedges[ar]);
                    this._link(ar, bl);

                    const br = b0 + (b + 1) % 3;
                    if (i < EDGE_STACK.length) { EDGE_STACK[i++] = br; }
                } else {
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                }
            }
            return ar;
        }

        _link(a, b) {
            this._halfedges[a] = b;
            if (b !== -1) this._halfedges[b] = a;
        }

        _addTriangle(i0, i1, i2, a, b, c) {
            const t = this.trianglesLen;
            this._triangles[t] = i0;
            this._triangles[t + 1] = i1;
            this._triangles[t + 2] = i2;
            this._link(t, a);
            this._link(t + 1, b);
            this._link(t + 2, c);
            this.trianglesLen += 3;
            return t;
        }
    }

    function pseudoAngle(dx, dy) {
        const p = dx / (Math.abs(dx) + Math.abs(dy));
        return (dy > 0 ? 3 - p : 1 + p) / 4;
    }

    function dist(ax, ay, bx, by) {
        const dx = ax - bx, dy = ay - by;
        return dx * dx + dy * dy;
    }

    function inCircle(ax, ay, bx, by, cx, cy, px, py) {
        const dx = ax - px, dy = ay - py;
        const ex = bx - px, ey = by - py;
        const fx = cx - px, fy = cy - py;
        const ap = dx * dx + dy * dy;
        const bp = ex * ex + ey * ey;
        const cp = fx * fx + fy * fy;
        return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
    }

    function circumradius(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax, dy = by - ay;
        const ex = cx - ax, ey = cy - ay;
        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);
        const x = (ey * bl - dy * cl) * d;
        const y = (dx * cl - ex * bl) * d;
        return x * x + y * y;
    }

    function circumcenter(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax, dy = by - ay;
        const ex = cx - ax, ey = cy - ay;
        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);
        return { x: ax + (ey * bl - dy * cl) * d, y: ay + (dx * cl - ex * bl) * d };
    }

    function orient(px, py, qx, qy, rx, ry) {
        return (qy - py) * (rx - qx) - (qx - px) * (ry - qy);
    }

    function quicksort(ids, dists, left, right) {
        if (right - left <= 20) {
            for (let i = left + 1; i <= right; i++) {
                const temp = ids[i], tempDist = dists[temp];
                let j = i - 1;
                while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
                ids[j + 1] = temp;
            }
        } else {
            const median = (left + right) >> 1;
            let i = left + 1, j = right;
            swap(ids, median, i);
            if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
            if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
            if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);
            const temp = ids[i], tempDist = dists[temp];
            while (true) {
                do i++; while (dists[ids[i]] < tempDist);
                do j--; while (dists[ids[j]] > tempDist);
                if (j < i) break;
                swap(ids, i, j);
            }
            ids[left + 1] = ids[j];
            ids[j] = temp;
            if (right - i + 1 >= j - left) {
                quicksort(ids, dists, i, right);
                quicksort(ids, dists, left, j - 1);
            } else {
                quicksort(ids, dists, left, j - 1);
                quicksort(ids, dists, i, right);
            }
        }
    }

    function swap(arr, i, j) { const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }
    function defaultGetX(p) { return p[0]; }
    function defaultGetY(p) { return p[1]; }

    // Voronoi class built on Delaunator - simple brute force approach
    class Voronoi {
        constructor(points, bounds) {
            this.points = points;
            this.bounds = bounds; // [xmin, ymin, xmax, ymax]
            this._delaunay = null;
            this._circumcenters = null;
            this._pointToTriangles = null; // Map point index -> list of triangle indices
            this.update();
        }

        update() {
            if (this.points.length < 3) return;

            this._delaunay = Delaunator.from(this.points);
            this._computeCircumcenters();
            this._buildPointToTriangles();
        }

        _computeCircumcenters() {
            const { _delaunay: { triangles, coords } } = this;
            const numTriangles = triangles.length / 3;
            this._circumcenters = new Float64Array(numTriangles * 2);

            for (let t = 0; t < numTriangles; t++) {
                const i0 = triangles[t * 3];
                const i1 = triangles[t * 3 + 1];
                const i2 = triangles[t * 3 + 2];
                const x0 = coords[i0 * 2], y0 = coords[i0 * 2 + 1];
                const x1 = coords[i1 * 2], y1 = coords[i1 * 2 + 1];
                const x2 = coords[i2 * 2], y2 = coords[i2 * 2 + 1];

                const c = circumcenter(x0, y0, x1, y1, x2, y2);
                this._circumcenters[t * 2] = c.x;
                this._circumcenters[t * 2 + 1] = c.y;
            }
        }

        _buildPointToTriangles() {
            const { _delaunay: { triangles }, points } = this;
            const numTriangles = triangles.length / 3;

            // For each point, store list of triangles containing it
            this._pointToTriangles = new Array(points.length);
            for (let i = 0; i < points.length; i++) {
                this._pointToTriangles[i] = [];
            }

            for (let t = 0; t < numTriangles; t++) {
                const i0 = triangles[t * 3];
                const i1 = triangles[t * 3 + 1];
                const i2 = triangles[t * 3 + 2];
                this._pointToTriangles[i0].push(t);
                this._pointToTriangles[i1].push(t);
                this._pointToTriangles[i2].push(t);
            }
        }

        cellPolygon(i) {
            if (!this._delaunay || this.points.length < 3) return null;
            if (i < 0 || i >= this.points.length) return null;

            const { _circumcenters, _pointToTriangles, bounds, points } = this;
            const [xmin, ymin, xmax, ymax] = bounds;

            // Get all triangles containing this point
            const triangleIndices = _pointToTriangles[i];
            if (!triangleIndices || triangleIndices.length === 0) return null;

            // Collect circumcenters
            const vertices = [];
            for (const t of triangleIndices) {
                vertices.push([_circumcenters[t * 2], _circumcenters[t * 2 + 1]]);
            }

            // Sort vertices by angle around the seed point
            const px = points[i][0], py = points[i][1];
            vertices.sort((a, b) => Math.atan2(a[1] - py, a[0] - px) - Math.atan2(b[1] - py, b[0] - px));

            // Check if this is a boundary cell (on convex hull)
            const hull = this._delaunay.hull;
            const isOnHull = hull.includes(i);

            if (isOnHull) {
                // For boundary cells, we need to extend to the bounding box
                // Add projected points and corners
                this._extendBoundaryCell(vertices, px, py);
            }

            if (vertices.length < 3) return null;

            // Clip to bounds
            return this._clip(vertices);
        }

        _extendBoundaryCell(vertices, px, py) {
            const [xmin, ymin, xmax, ymax] = this.bounds;

            // Project first and last circumcenters outward
            if (vertices.length >= 2) {
                const first = vertices[0];
                const last = vertices[vertices.length - 1];

                // Project in direction away from seed point
                const proj1 = this._projectRay(first[0], first[1], px, py);
                const proj2 = this._projectRay(last[0], last[1], px, py);

                if (proj1) vertices.unshift(proj1);
                if (proj2) vertices.push(proj2);
            }

            // Add corners that belong to this cell
            const corners = [[xmin, ymin], [xmax, ymin], [xmax, ymax], [xmin, ymax]];
            for (const corner of corners) {
                if (this._isClosestPoint(corner[0], corner[1], px, py)) {
                    vertices.push(corner);
                }
            }

            // Re-sort after adding new vertices
            vertices.sort((a, b) => Math.atan2(a[1] - py, a[0] - px) - Math.atan2(b[1] - py, b[0] - px));
        }

        _projectRay(cx, cy, px, py) {
            const [xmin, ymin, xmax, ymax] = this.bounds;

            // Direction from seed point through circumcenter
            const dx = cx - px;
            const dy = cy - py;
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len < 0.001) return null;

            // Normalize
            const ndx = dx / len;
            const ndy = dy / len;

            // Find intersection with bounding box
            let tMin = Infinity;

            if (ndx > 0) tMin = Math.min(tMin, (xmax - cx) / ndx);
            else if (ndx < 0) tMin = Math.min(tMin, (xmin - cx) / ndx);

            if (ndy > 0) tMin = Math.min(tMin, (ymax - cy) / ndy);
            else if (ndy < 0) tMin = Math.min(tMin, (ymin - cy) / ndy);

            if (tMin === Infinity || tMin < 0) return null;

            return [cx + ndx * tMin, cy + ndy * tMin];
        }

        _isClosestPoint(x, y, px, py) {
            const distToP = (x - px) * (x - px) + (y - py) * (y - py);

            for (const other of this.points) {
                if (other[0] === px && other[1] === py) continue;
                const distToOther = (x - other[0]) * (x - other[0]) + (y - other[1]) * (y - other[1]);
                if (distToOther < distToP - 0.001) {
                    return false;
                }
            }
            return true;
        }

        _clip(polygon) {
            const [xmin, ymin, xmax, ymax] = this.bounds;

            const clips = [
                { inside: p => p[0] >= xmin, intersect: (a, b) => [xmin, a[1] + (b[1] - a[1]) * (xmin - a[0]) / (b[0] - a[0])] },
                { inside: p => p[0] <= xmax, intersect: (a, b) => [xmax, a[1] + (b[1] - a[1]) * (xmax - a[0]) / (b[0] - a[0])] },
                { inside: p => p[1] >= ymin, intersect: (a, b) => [a[0] + (b[0] - a[0]) * (ymin - a[1]) / (b[1] - a[1]), ymin] },
                { inside: p => p[1] <= ymax, intersect: (a, b) => [a[0] + (b[0] - a[0]) * (ymax - a[1]) / (b[1] - a[1]), ymax] }
            ];

            let output = polygon;

            for (const { inside, intersect } of clips) {
                if (output.length === 0) break;
                const input = output;
                output = [];

                for (let j = 0; j < input.length; j++) {
                    const curr = input[j];
                    const prev = input[(j + input.length - 1) % input.length];

                    if (inside(curr)) {
                        if (!inside(prev)) {
                            output.push(intersect(prev, curr));
                        }
                        output.push(curr);
                    } else if (inside(prev)) {
                        output.push(intersect(prev, curr));
                    }
                }
            }

            return output.length >= 3 ? output : null;
        }

        findCell(x, y) {
            let minDist = Infinity;
            let closest = -1;
            for (let i = 0; i < this.points.length; i++) {
                const dx = this.points[i][0] - x;
                const dy = this.points[i][1] - y;
                const d = dx * dx + dy * dy;
                if (d < minDist) {
                    minDist = d;
                    closest = i;
                }
            }
            return closest;
        }
    }

    // Main Application
    (function() {
        const config = {
            cellCount: 12,
            showImages: true
        };

        const colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
            '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
            '#F8B500', '#00CED1', '#FF69B4', '#32CD32', '#FF7F50'
        ];

        let canvas, ctx;
        let width, height;
        let points = [];
        let voronoi = null;

        function init() {
            canvas = document.getElementById('voronoiCanvas');
            ctx = canvas.getContext('2d');

            resize();
            generatePoints();
            render();

            window.addEventListener('resize', () => { resize(); generatePoints(); render(); });

            document.getElementById('cellCount').addEventListener('input', (e) => {
                config.cellCount = parseInt(e.target.value);
                document.getElementById('cellCountValue').textContent = config.cellCount;
            });

            document.getElementById('regenerate').addEventListener('click', () => {
                generatePoints();
                render();
            });

            document.getElementById('toggleMode').addEventListener('click', (e) => {
                config.showImages = !config.showImages;
                e.target.textContent = config.showImages ? 'Show Colors' : 'Show Numbers';
                render();
            });
        }

        function resize() {
            const wrapper = canvas.parentElement;
            const rect = wrapper.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;

            width = rect.width;
            height = rect.height;

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function generatePoints() {
            points = [];
            const margin = 50;

            // Simple random distribution with minimum distance
            const minDist = Math.sqrt((width * height) / config.cellCount) * 0.5;

            for (let attempts = 0; points.length < config.cellCount && attempts < 1000; attempts++) {
                const x = margin + Math.random() * (width - 2 * margin);
                const y = margin + Math.random() * (height - 2 * margin);

                let valid = true;
                for (const p of points) {
                    const dx = p[0] - x, dy = p[1] - y;
                    if (dx * dx + dy * dy < minDist * minDist) {
                        valid = false;
                        break;
                    }
                }

                if (valid) {
                    points.push([x, y]);
                }
            }

            // Fill remaining if needed
            while (points.length < config.cellCount) {
                points.push([
                    margin + Math.random() * (width - 2 * margin),
                    margin + Math.random() * (height - 2 * margin)
                ]);
            }

            voronoi = new Voronoi(points, [0, 0, width, height]);
        }

        function render() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            if (!voronoi || points.length < 3) return;

            // Draw cells
            for (let i = 0; i < points.length; i++) {
                const polygon = voronoi.cellPolygon(i);
                if (!polygon || polygon.length < 3) continue;

                // Fill
                ctx.beginPath();
                ctx.moveTo(polygon[0][0], polygon[0][1]);
                for (let j = 1; j < polygon.length; j++) {
                    ctx.lineTo(polygon[j][0], polygon[j][1]);
                }
                ctx.closePath();

                ctx.fillStyle = colors[i % colors.length];
                ctx.fill();

                // Border
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Number label
                if (config.showImages) {
                    const cx = polygon.reduce((s, p) => s + p[0], 0) / polygon.length;
                    const cy = polygon.reduce((s, p) => s + p[1], 0) / polygon.length;

                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.font = 'bold 32px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(i + 1, cx, cy);
                }
            }

            // Draw seed points
            ctx.fillStyle = '#fff';
            for (const p of points) {
                ctx.beginPath();
                ctx.arc(p[0], p[1], 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    })();
    </script>
</body>
</html>
